## 레디스를 캐시로 사용하기

### 캐시란?
+ 데이터의 원본보다 더 빠르고 효율적으로 액세스할 수 있는 임시 데이터 저장
+ 애플리케이션이 다음 조건을 만족한다면 캐시를 도입했을 때, 성능을 효과적으로 개선가능
    - 원본 데이터 저장소에서 원하는 데이터를 찾기위해 검색하는 시간이 오래 걸리거나 매번 계산을 통해 데이터를 가져와야 할 때
    - 캐시에서 데이터를 가져오는 것이 원본 데이터 저장소에서 요청하는 것보다 빨라야 함
    - 캐시에 저장된 데이터는 잘 변하지 않는 데이터다
    - 캐시에 저장된 데이터는 자주 검색되는 데이터다

### 캐시로서의 레디스
+ 키-값 형태로 저장하므로 데이터를 저장하고 반환하는 것이 간단하다
+ 자체적으로 다양한 자료구조를 지원하므로 애플리케이션에서 사용하던 list, hash 등의 자료구조를 변환하는 과정없이 바로 저장가능
+ 모든 데이터를 메모리에 저장하는 인메모리 데이터 저장소이기 떄문에 읽고 쓰기가 빠르다
+ 레디스의 센티널, 클러스터 기능을 사용하면 마스터 노드의 장애를 자동으로 감지해 페일오버를 발생하기 때문에 운영자의 개입이 없어도 캐시는 정상으로 유지된다
+ 클러스터를 사용하여 캐시의 스케일 아웃을 쉽게 처리할 수 있다

### 캐싱 전략
+ 읽기 전략 look aside
    - 레디스를 캐시로 사용할 때 가장 일반적인 방법
    - 애플리케이션이 찾고자 하는 데이터가 캐시에 있는지 확인한 뒤, 데이터가 있으면 캐시에서 읽어온다(`캐시 히트`)
    - 찾고자하는 데이터가 없는 경우 캐시 미스가 발생하며 원본 데이터베이스에 접근해 데이터를 가져온 후, 캐시에 저장한다
    - 장점  
        + 레디스에 문제가 생겨 접근이 어려운 상황이 발생하더라도 원본 데이터베이스에서 데이터를 가져올 수 있다
    - 단점
        + 애플리케이션에서 레디스를 통해 데이터를 가져오는 부분이 많았다면 모든 커넥션이 원본 데이터베이스로 몰려 많은 부하를 발생시켜 애플리케이션의 성능에 영향을 미칠 수 있다
    - 찾고자하는 데이터가 레디스에 없을 때만 레디스에 데이터자 저장되기 때문에 `lazy loading`으로 부르기도 한다
    - 원본 데이터베이스에만 데이터를 저장하고 레디스에 캐싱하지 않으면 애플리케이션은 매번 레디스에 접근할 것이다
    이것을 방지하기 위해 데이터를 미리 밀어넣기도 하는데 이것을 `캐시 워밍`이라고 한다

### 쓰기 전략과 캐시의 일관성
+ 캐시는 원본 데이터베이스에 저장된 데이터를 단순히 복사해온 값
    - 따라서 원본 데이터베이스와 항상 동일한 값을 유지하는 것이 중요하다
    - 데이터가 변경될 때, 원본 데이터베이스에만 업데이트되어 캐시에는 반영되지 않는다면 데이터 간 불일치 발생(`캐시 불일치`)
    - 캐시를 이용한 쓰기 전략은 최대 3가지가 있다
        + write through
            - 데이터베이스에 업데이트할 때마다 매번 캐시에도 데이터를 업데이트하는 방법
            - 캐시는 항상 최신 데이터를 유지할 수 있으나 데이터는 매번 2회 저장되어야 한다
            - 다시 사용될만한 데이터를 캐시로 사용하는 것이 좋은데, 이 방법을 사용하면 무조건 캐시에 저장되므로 데이터 만료 시간을 사용하는 것이 권장된다
        + cache invalidation
            - 데이터베이스에 값을 업데이트할 때마다 캐시에서 데이터를 삭제하는 방법
            - 저장소에서 특정 데이터를 삭제하는 것이 새로운 데이터를 저장하는 것보다 적은 리소스를 사용하므로 write-through의 단점을 보완한 방법이라고 볼 수 있다
        + write behind(write back)
            - 쓰기가 빈번하게 발생하는 서비스에서 고려할 수 있는 방법
            - 데이터베이스에 대량의 쓰기 작업이 발생하면 많은 디스크 I/O를 유발해 성능 저하가 발생할 수 있다
            - 따라서 데이터를 빠르게 접근할 수 있는 캐시에 업데이트 후, 비동기적으로 원본 데이터베이스에 업데이트한다

### 캐시에서의 데이터 흐름
+ 캐시는 데이터 스토어가 갖고 있는 데이터 중 사용자가 자주 사용할만한 데이터를 가져와 임시로 저장한다
    - 원본 데이터베이스의 서브셋이라고 생각할 수 있다
    - 레디스는 메모리에 모든 데이터를 저장하며 메모리는 서버의 스토리지보다 적은 저장량을 가질 수 밖에 없다
    > 따라서 메모리가 가득 차지 않도록 레디스의 데이터를 관리할 필요가 있다

+ 만료시간(TTL)
    - 레디스 키가 자동으로 만료되어 삭제되기까지 남은 시간을 의미
    - 데이터에 생존 시간을 설정하여 일정 시간 후 자동으로 삭제시킨다
    - 주요특징
        + 자동만료 : 설정된 시간이 지나면 레디스가 자동으로 키를 삭제
        + 메모리 관리 : 불필요한 데이터를 자동으로 정리하여 메모리 사용량을 효율적으로 관리가능
        + 캐시구현 : 임시 데이터나 캐시 데이터의 생명주기 관리에 유리

        ```bash
        # TTL 설정 (초 단위)
        EXPIRE key 3600

        # TTL 설정 (밀리초 단위)  
        PEXPIRE key 3600000

        # 특정 시각에 만료 설정
        EXPIREAT key 1640995200

        # TTL 확인
        TTL key

        # TTL 제거 (영구 보관)
        PERSIST key

        # TTL과 EXPIRE는 초단위로 동작
        # PTTL과 PEXPIRE는 밀리세컨드 단위로 동작
        ```
    - 키에 만료시간을 설정하면 INCR 등의 커맨드로 데이터를 변경하거나 이름을 바꾸어도 설정된 만료시간은 변경되지 않는다
    - 기존 키에 새로운 값을 저장하여 덮어쓰면 설정한 만료시간은 삭제된다

+ 레디스 키 삭제방식
    - passive 방식
        + 지연 삭제 방식 : 클라이언트가 키에 접근할 때, TTL을 확인하여 만료된 경우 삭제
        + 키가 만료되었어도 사용자가 접근하지 않으면 삭제되지 않는다
    - active 방식
        + 주기적 삭제 : 레디스가 주기적으로 만료된 키를 찾아서 삭제
        + 별도의 타이머가 돌아가며 삭제 프로세스를 수행

### 메모리 관리와 maxmemory-policy 설정
+ 레디스는 인메모리 데이터베이스로서 효율적인 메모리 관리가 중요하다
    - 메모리가 부족해지면 새로운 데이터를 저장할 수 없거나 서버가 불안정해질 수 있다
        ```bash
        # redis.conf 설정
        maxmemory 2gb                    # 최대 메모리 사용량 설정
        maxmemory-policy allkeys-lru     # 메모리 정책 설정
        maxmemory-samples 5              # LRU 샘플링 개수
        ```
    - noeviction
        + 메모리 정책의 기본값
        + 레디스에 데이터가 가득 차더라도 데이터를 삭제하지 않고 데이터를 저장할 수 없다는 에러를 반환
        + 읽기 명령은 정상적으로 동작
        + 데이터의 관리를 애플리케이션 측에서 관리하겠다는 것을 의미
    - LRU eviction
        + LRU(Least-Recently Used) `최근 사용 시간` 기준
        + 가장 오래 전에 사용된 데이터를 제거
            - volatile-lru
                + 만료시간이 설정된 키가 대상
                + 만료시간이 설정된 것은 언젠가 삭제될 키이므로 가장 오래된 키부터 삭제하는 방식
                + 레디스에 저장된 모든 키가 만료시간을 가지지 않는다면 noeviction과 동일
            - allkeys-lru
                + 레디스가 권장하는 방식
                + 모든 키에 대해 LRU 알고리즘을 사용해 데이터를 삭제한다
    - LFU eviction
        + LFU(Least Frequently Used) `사용빈도` 기준
        + 가장 적게 사용된 데이터를 제거
            - volatile-lfu
                + 만료시간이 설정된 키가 대상
                + volatile-lfu와 같은 장단점을 공유한다
            - allkeys-lfu
                + 모든 키에 대해 LFU 알고리즘을 사용해 데이터를 삭제한다
    - RANDON eviction
        + 레디스에 저장된 키 중 하나를 임의로 골라내어 삭제
        + 랜덤으로 키를 삭제하기 때문에 중요한 데이터를 삭제할 가능성도 존재한다
            - volatile-random
                + 만료시간이 설정되어 있는 키가 대상으로 랜덤하게 삭제
            - allkeys-random
                + 모든 키에 대해 랜덤하게 키를 삭제
    - volatile-ttl
        + 만료시간이 가장 작은 키를 삭제한다

### 캐시 스탬피드 현상
+ 캐시된 데이터가 만료되는 순간 동시에 여러 스레드나 프로세스가 같은 데이터를 캐시에서 조회하고 캐시 미스가 발생하여 모두 원본 데이터에 접근하는 현상

    ```java
    @Service
    public class ProductService {
        
        @Autowired
        private RedisTemplate<String, String> redisTemplate;
        
        @Autowired
        private ProductRepository productRepository;
        
        public Product getProduct(Long productId) {
            String cacheKey = "product:" + productId;
            String cachedProduct = redisTemplate.opsForValue().get(cacheKey);
            
            if (cachedProduct == null) {
                // 캐시 미스 - 모든 스레드가 동시에 DB 접근!
                Product product = productRepository.findById(productId);
                redisTemplate.opsForValue().set(cacheKey, 
                    JSON.toJSONString(product), Duration.ofMinutes(30));
                return product;
            }
            
            return JSON.parseObject(cachedProduct, Product.class);
        }
    }
    ```

    - 해결방법
        + 분산 락(Distributed Lock) 사용
            ```java
            @Service
            public class ProductService {
                
                @Autowired
                private RedissonClient redissonClient;
                
                @Autowired
                private RedisTemplate<String, String> redisTemplate;
                
                @Autowired
                private ProductRepository productRepository;
                
                public Product getProduct(Long productId) {
                    String cacheKey = "product:" + productId;
                    String cachedProduct = redisTemplate.opsForValue().get(cacheKey);
                    
                    if (cachedProduct == null) {
                        RLock lock = redissonClient.getLock("lock:product:" + productId);
                        
                        try {
                            // 최대 10초 대기, 5초 후 자동 해제
                            if (lock.tryLock(10, 5, TimeUnit.SECONDS)) {
                                try {
                                    // 다시 한번 캐시 확인 (다른 스레드가 이미 캐시했을 수 있음)
                                    cachedProduct = redisTemplate.opsForValue().get(cacheKey);
                                    if (cachedProduct != null) {
                                        return JSON.parseObject(cachedProduct, Product.class);
                                    }
                                    
                                    // DB에서 데이터 조회 및 캐시
                                    Product product = productRepository.findById(productId);
                                    redisTemplate.opsForValue().set(cacheKey, 
                                        JSON.toJSONString(product), Duration.ofMinutes(30));
                                    return product;
                                } finally {
                                    lock.unlock();
                                }
                            } else {
                                // 락 획득 실패 - 캐시 없이 DB 조회
                                return productRepository.findById(productId);
                            }
                        } catch (InterruptedException e) {
                            Thread.currentThread().interrupt();
                            return productRepository.findById(productId);
                        }
                    }
                    
                    return JSON.parseObject(cachedProduct, Product.class);
                }
            }
            ```

        + 캐시 예열
            - 만료를 기다리는 것이 아닌 능동적으로 미리 캐시를 갱신하는 전략
            ```java
            @Component
            public class CacheWarmupService {
                
                @Autowired
                private RedisTemplate<String, String> redisTemplate;
                
                @Autowired
                private ProductRepository productRepository;
                
                @Scheduled(fixedRate = 1800000) // 30분마다 실행
                public void warmupPopularProducts() {
                    List<Long> popularProductIds = getPopularProductIds();
                    
                    for (Long productId : popularProductIds) {
                        String cacheKey = "product:" + productId;
                        Long ttl = redisTemplate.getExpire(cacheKey);
                        
                        // TTL이 5분 미만인 경우 미리 갱신
                        if (ttl != null && ttl < 300) {
                            Product product = productRepository.findById(productId);
                            redisTemplate.opsForValue().set(cacheKey, 
                                JSON.toJSONString(product), Duration.ofMinutes(30));
                        }
                    }
                }
                
                private List<Long> getPopularProductIds() {
                    // 인기 상품 ID 목록 반환 로직
                    return Arrays.asList(1L, 2L, 3L, 4L, 5L);
                }
            }
            ```

        + PER 알고리즘
            - 캐시가 만료되기 전에 확률적으로 미리 갱신하는 방법
            - 장점
                + 부드러운 부하 분산 : 갱신요청이 알고리즘에 따라 분산됨
                + 높은 캐시 히트율 : 캐시가 만료되기 전에 미리 갱신
                + 락이나 복잡한 동기화가 불필요
                + 트래픽 증가에도 효과적
            - 단점
                + 불필요한 갱신 : 확률적으로 동작하므로 불필요하게 DB에 접근하는 경우가 존재
                + 예측 불가능 : 정확히 언제 갱신될지 확인이 어려움

### 세션 스토어로서의 레디스
+ 캐시와 세션의 차이
    - 캐시로 사용할 때
        + 캐시는 데이터베이스의 완벽한 서브셋
        + 캐시가 가지고 있는 데이터는 모두 데이터베이스에 저장되어 있으며 캐시가 유실되더라도 데이터베이스에서 찾을 수 있다
    - 세션 스토어로 사용할 때
        + 세션이 활성화되어 있는 동안에는 모든 유저정보는 세션 스토어에만 저장
        + 유저가 로그아웃할 때, 세션은 종료되며 데이터의 종류에 따라 데이터베이스에 저장하여 관리할 것인지 삭제할 것인지 결정된다
        + 따라서 레디스를 세션 스토어로 활용할 때는 캐시로 사용할때보다 신중한 운영이 필요