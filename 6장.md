## 레디스를 메시지 브로커로 사용하기

### 메시지 브로커의 핵심 역할
+ 최근 서비스 아키텍처는 여러 모듈이 서로 느슨하고 적절하게 연결시킨 구조를 선호
    - 이러한 구조는 다양한 장점이 있지만 모듈간 서로 상호 작용이 필요하므로 메시지 브로커를 필요로 함
+ 서비스 간 커넥션이 실패하는 상황은 언제나 발생가능
    - 따라서 모듈 간 통신은 비동기 통신을 사용하는 것을 권장한다
    - 서비스 간 통신이 불가능한 상황이 바로 장애로 이어지지 않도록 하고
    - 당장 메시지를 처리하지 못하더라도 메시지를 어딘가에 저장 후, 나중에 처리할 수 있는 채널을 만드는 것
    > `메시지 브로커의 핵심역할`

### 메시징 큐와 이벤트 스트림
+ 메시징 큐
    - 애플리케이션 간에 비동기적으로 메시지를 전달하는 통신패턴
    - 레디스에서는 주로 List와 Pub/Sub 기능을 활용

    ```java
    // 메시지 생성자
    import redis.clients.jedis.Jedis;
    import com.fasterxml.jackson.databind.ObjectMapper;

    public class MessageProducer {
        private Jedis jedis;
        private ObjectMapper objectMapper;
        
        public MessageProducer() {
            this.jedis = new Jedis("localhost", 6379);
            this.objectMapper = new ObjectMapper();
        }
        
        public void sendMessage(String queueName, Object message) {
            try {
                String jsonMessage = objectMapper.writeValueAsString(message);
                jedis.lpush(queueName, jsonMessage);
                System.out.println("메시지 전송: " + jsonMessage);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }

    // 메시지 소비자
    public class MessageConsumer {
        private Jedis jedis;
        private ObjectMapper objectMapper;
        
        public MessageConsumer() {
            this.jedis = new Jedis("localhost", 6379);
            this.objectMapper = new ObjectMapper();
        }
        
        public void consumeMessages(String queueName) {
            while (true) {
                try {
                    // 블로킹 방식으로 메시지 대기 (5초 타임아웃)
                    List<String> messages = jedis.brpop(5, queueName);
                    if (messages != null && messages.size() > 1) {
                        String message = messages.get(1);
                        processMessage(message);
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }
        
        private void processMessage(String message) {
            System.out.println("메시지 처리: " + message);
            // 비즈니스 로직 처리
        }
    }
    ```

+ 이벤트 스트림
    - 시간 순서대로 발생하는 이벤트들의 연속된 흐름
    - 레디스에서는 Redis Stream을 사용하여 구현

    ```java
    // 이벤트 생산자
    import redis.clients.jedis.StreamEntryID;
    import java.util.HashMap;
    import java.util.Map;

    public class EventStreamProducer {
        private Jedis jedis;
        
        public EventStreamProducer() {
            this.jedis = new Jedis("localhost", 6379);
        }
        
        public void publishEvent(String streamName, Map<String, String> eventData) {
            try {
                // 자동으로 ID 생성하여 스트림에 이벤트 추가
                StreamEntryID id = jedis.xadd(streamName, StreamEntryID.NEW_ENTRY, eventData);
                System.out.println("이벤트 발행됨 - ID: " + id);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        
        public void publishUserEvent(String userId, String eventType, String data) {
            Map<String, String> eventData = new HashMap<>();
            eventData.put("userId", userId);
            eventData.put("eventType", eventType);
            eventData.put("data", data);
            eventData.put("timestamp", String.valueOf(System.currentTimeMillis()));
            
            publishEvent("user-events", eventData);
        }
    }

    // 이벤트 소비자
    import redis.clients.jedis.StreamEntry;
    import redis.clients.jedis.StreamEntryID;
    import redis.clients.jedis.params.XReadGroupParams;
    import java.util.List;
    import java.util.Map;

    public class EventStreamConsumer {
        private Jedis jedis;
        private String consumerGroup;
        private String consumerName;
        
        public EventStreamConsumer(String consumerGroup, String consumerName) {
            this.jedis = new Jedis("localhost", 6379);
            this.consumerGroup = consumerGroup;
            this.consumerName = consumerName;
        }
        
        public void createConsumerGroup(String streamName) {
            try {
                // 컨슈머 그룹 생성 (스트림 시작부터 읽기)
                jedis.xgroupCreate(streamName, consumerGroup, new StreamEntryID(), false);
            } catch (Exception e) {
                // 이미 존재하는 그룹일 경우 무시
                System.out.println("컨슈머 그룹이 이미 존재합니다.");
            }
        }
        
        public void consumeEvents(String streamName) {
            createConsumerGroup(streamName);
            
            while (true) {
                try {
                    // 컨슈머 그룹으로부터 메시지 읽기
                    Map<String, List<StreamEntry>> result = jedis.xreadGroup(
                        consumerGroup,
                        consumerName,
                        XReadGroupParams.xReadGroupParams().block(1000).count(10),
                        Map.of(streamName, StreamEntryID.UNRECEIVED_ENTRY)
                    );
                    
                    if (result != null && !result.isEmpty()) {
                        List<StreamEntry> entries = result.get(streamName);
                        for (StreamEntry entry : entries) {
                            processEvent(streamName, entry);
                            // 메시지 처리 완료 확인
                            jedis.xack(streamName, consumerGroup, entry.getID());
                        }
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                    try {
                        Thread.sleep(1000);
                    } catch (InterruptedException ie) {
                        Thread.currentThread().interrupt();
                        break;
                    }
                }
            }
        }
        
        private void processEvent(String streamName, StreamEntry entry) {
            System.out.println("이벤트 처리 - Stream: " + streamName + 
                            ", ID: " + entry.getID() + 
                            ", Data: " + entry.getFields());
            // 비즈니스 로직 처리
        }
    }

    public class EventStreamExample {
        public static void main(String[] args) {
            // Producer 사용
            EventStreamProducer producer = new EventStreamProducer();
            producer.publishUserEvent("user123", "login", "successful");
            producer.publishUserEvent("user456", "purchase", "product-abc");
            
            // Consumer 사용
            EventStreamConsumer consumer = new EventStreamConsumer("analytics-group", "consumer-1");
            
            // 별도 스레드에서 이벤트 소비
            new Thread(() -> consumer.consumeEvents("user-events")).start();
        }
    }
    ```

+ 주요 차이점
    - 메시지 큐의 특징
        + 일대일 통신(한 메시지는 한 사용자가 처리, 큐 자료구조를 생각하자)
        + 메시지가 소비되면 큐에서 제거됨
            - 나중에 추가된 사용자가 이전 메시지를 처리할 수 없음
        + 간단한 작업 분산에 적합
    - 이벤트 스트림의 특징
        + 일대다 통신 가능(여러 소비자가 같은 이벤트 처리)
        + 이벤트가 스트림에 영구 저장
            - 나중에 추가된 사용자도 이벤트 순서에 따라 처리가능
        + 시간 순서 보장

### 메시지 발행하기
+ publish 커맨드를 사용해 메시지를 전파할 수 있다
    ```bash
    publish hello world
    ```
    - publish 커맨드를 사용하면 hello 채널을 수신하고 있는 모든 서버에게 world라는 메시지가 전파된다
    - 메시지 전파 후에는 메시지를 수신한 구독자 수가 반환된다

+ subscribe 커맨드를 사용해서 채널을 구독할 수 있다
    ```bash
    subscribe event1 event2
    ```
    - subscribe 커맨드를 사용하면 입력한 채널을 구독할 수 있다
    - 클라이언트가 구독자로 동작할 때, 새로운 채널을 구독할 수 있지만 pub/sub와 관련되지 않은 다른 커맨드는 실행할 수 없다
        + 클라이언트가 `구독 모드`로 전환
        + 왜 이런 제한이 있을까?
            - 프로토콜 설계 관점 : 레디스 pub/sub는 `push 방식`으로 동작, 서버가 구독자에게 지속적으로 메시지를 푸시하는 상태에서는 일반적인 요청-응답 패턴을 사용할 수 없다
            - 연결상태 관리 : 구독 모드에서는 클라이언트가 `듣기 대기` 상태가 되어 서버로부터 오는 메시지를 받기 위해 연결을 점유
            - 동시성 문제 방지 : 메시지 수신과 일반 명령 실행이 동시에 일어나면 응답을 구분하기 어려워짐
        + 이런 제약은 레디스가 싱글 스레드로 동작하기 때문에?
            - 레디스는 6.0부터 멀티 스레드를 지원하지만 구독 모드 제약은 동일
            - 진짜 이유는 `네트워크 프로토콜의 설계`
                + 하나의 TCP 연결에서 두가지 다른 통신 패턴을 동시에 처리할 수 없다

                ```bash
                // 일반 명령 : 요청-응답 패턴
                Client -> Server: GET mykey
                Client <- Server: "myvalue"

                Client -> Server: SET anotherkey "value"  
                Client <- Server: OK

                // Pub/Sub : 비동기 푸시 패턴
                Client -> Server: SUBSCRIBE mychannel
                Client <- Server: 구독 확인 메시지

                # 이후 언제든지 서버가 푸시
                Client <- Server: 메시지1
                Client <- Server: 메시지2
                Client <- Server: 메시지3
                ```

            - 아파치 카프카와 RabbitMQ와 같은 전용 메시징 시스템도 비슷한 제약이 존재
            > 레디스의 싱글 스레드 특성보다는 **네트워크 프로토콜의 본질적인 제약**으로 보는 것이 더 정확
    - psubscribe 커맨드를 사용하면 일치하는 패턴에 해당하는 모든 채널을 구독할 수 있다
        + psubscribe 커맨드는 pmessage 타입으로 메시지를 전달받으며 pmessage는 message 타입에서 `패턴` 정보가 추가된 형태

        ```
        message: 3개 필드 (메시지타입, 채널명, 내용)
        pmessage: 4개 필드 (메시지타입, 패턴, 실제채널명, 내용)
        ```

### 클러스터 구조의 Pub/Sub
+ 레디스 클러스터에서 Pub/Sub은 단일 레디스 인스턴스와 다른 특성을 가진다
    - 전체 클러스터 브로드 캐스트
        + 레디스 클러스터에서 메시지를 발행하면 클러스터에 속한 `모든 노드`에 브로드캐스트된다
            - 단일 인스턴스
                + 모든 구독자가 같은 서버에 연결
                + 메시지를 발행하면 서버의 모든 구독자가 수신
            - 클러스터
                + 구독자들이 여러 노드에 분산되어 있음
                + 메시지를 발행하면 모든 구독자가 수신해야 함
                + 따라서 모든 노드에 브로드캐스트 진행

        |환경|키-값 데이터|Pub/Sub 데이터|
        |---|---|---|
        |단일 인스턴스|하나의 서버에 저장|하나의 서버에서 처리|
        |클러스터|샤딩으로 분산 저장|모든 노드에 브로드캐스트|

### 레디스 list를 메시징 큐로 사용하기
+ 자료구조 list는 메시징 큐로 사용하기 적절한 자료구조다
    - 큐의 tail과 head에서 데이터를 넣고 뺄 수 있는 lpush, lpop, rpush, rpop 등의 커맨드가 존재하기 때문

+ list의 ex 옵션
    - 타임라인 캐시에 데이터를 저장한다고 가정할 때, rpushx 커맨드를 사용할 수 있다
    - rpushx는 데이터를 저장하고자 하는 list가 존재할 때, 데이터를 추가하는 커맨드
    - 해당 커맨드로 캐시를 관리하면 이미 캐시된(키가 존재하는) 타임라인에만 데이터를 추가할 수 있다
        + 타임라인 캐시가 저장되지 않은 유저는 타임라인 캐시 데이터를 관리할 필요가 없기 때문

+ list의 블로킹 기능
    - 폴링
        + 폴링은 서버나 시스템이 새 데이터가 추가되었는지 주기적으로 확인하는 방식
        + 장점
            - 구현이 단순하다
            - 시스템이 스스로 제어가 가능하다(언제 요청할지)
        + 단점
            - 리소스 낭비(주기적으로 확인하므로)
            - 데이터가 없어도 무의미한 요청을 반복할 수 있다
            - 실시간성이 떨어진다(데이터가 추가되어도 확인주기가 아니면 이벤트 진행 불가)
    
    - 블로킹
        + 데이터가 없으면 잠깐 멈추고 기다렸다가 데이터가 추가되면 바로 응답하는 방식
        + 장점
            - 데이터가 추가되면 동작하므로 대기 리소스를 줄일 수 있음
            - 실시간성이 높음
        + 단점
            - 클라이언트가 `대기상태`가 됨
            - 타임아웃 설정에 따라 무한정 대기하는 상태가 될 수 있다

### Stream
+ 스트림은 대용량, 대규모의 메시징 데이터를 빠르게 처리할 수 있도록 설계된 자료구조
+ 레디스에서는 하나의 스트림 자료구조가 하나의 스트림을 의미한다
    - 레디스 스트림에서 각 메시지는 시간과 관련된 유니크한 ID를 가지며 중복되지 않는다
    - ID는 다음과 같이 두개의 파트로 나뉜다
        ```bash
        <millisecondsTime>-<sequenceNumber>
        ```
        + 밀리세컨드 파트는 실제 stream에 아이템이 저장될 시점의 레디스 노드 로컬 시간이다
        + 시퀀스 번호는 64bit
+ 스트림 생성과 데이터 입력
    - xadd 커맨드를 사용해 스트림을 생성 및 데이터를 입력할 수 있다
        + 기존에 같은 키의 스트림이 존재했다면 기존 스트림에 새로운 메시지를 추가한다
        ```bash
        127.0.0.1:6379> xadd email * subject "first" body "hello?"
        "1757680561744-0"
        127.0.0.1:6379> 
        ```
        + 만약에 자동으로 생성되는 ID가 아니라 ID를 지정하고 싶으면 필드에 *가 아닌 ID를 지정하면 된다
            - 이 경우 지정할 수 있는 최소 ID값은 0-1이며 이후에 저장되는 스트림의 ID는 이전에 저장됐던 ID값보다 작은 값으로 지정할 수 없다
        ```bash
        127.0.0.1:6379> xadd mystream 0-1 "hello" "world"
        "0-1"
        ```
+ 데이터의 조회
    - 레디스에서 스트림 데이터를 조회하는 방법은 두가지가 존재한다
        + 실시간으로 처리되는 데이터를 리스닝
        + ID를 사용해 필요한 데이터 검색
    - xread 커맨드를 이용해 실시간으로 스트림에 저장되는 데이터를 읽을 수 있다
        + 아래는 새로운 메시지가 들어올 때까지 스트림을 리스닝하면서 기다리는 커맨드다
        + block 0은 스트림에서 가져올 데이터가 없더라도 연결을 끊지말고 계속 스트림을 리스닝하라는 의미
            - block 1000을 입력하면 들어오는 데이터가 없더라도 1000ms 즉 최대 1초동안 연결을 유지하며 대기하라는 것을 의미
        + streams email 0이라는 커맨드는 email이라는 스트림에 저장된 데이터 중 ID가 0보다 큰 값을 읽어오라는 의미, 즉 스트림에 저장된 모든 데이터를 읽어오라는 의미
            - 0 대신에 특수 ID $를 입력하면 커맨드를 실행한 이후의 메시지만 가져온다, 스트림에 저장된 최대 ID로 볼 수 있다

            ```bash
            127.0.0.1:6379> xread block 0 streams email 0
            1) 1) "email"
            2) 1) 1) "1757680561744-0"
                    2) 1) "subject"
                        2) "first"
                        3) "body"
                        4) "hello?"
            ```
    - xrange 커맨드를 사용하면 ID를 이용해 원하는 시간대의 데이터를 조회할 수 있다
        + 스트림에 저장된 ID 중 가장 작은 ID값을 지정하고 싶을 때는 -, 제일 마지막 ID값을 지정하고 싶을때는 +
    - xrevrange는 xrange의 역순으로 데이터를 조회할 수 있다
    - xread와 xrange의 차이
        + xrange : 정적 범위 읽기
            - 히스토리 데이터 조회에 적합
            - 특정 범위의 메시지 한번에 읽기
            - 즉시 반환(블로킹 없음)
            - 과거 데이터 분석이나 배치 처리에 주로 사용
        + xread : 실시간 스트리밍 읽기
            - 실시간 데이터 처리에 적합
            - 특정 ID 이후에 새로운 메시지만 읽기
            - 블로킹 가능(새 메시지가 올때까지 대기, 즉시 반환)
                + 한번 반환하고 끝 : 새 메시지가 오면 즉시 반환하고 블로킹 해제
                + 지속적 처리 필요 : 계속 메시지를 받으려면 루프로 반복 호출
                + 타임아웃
            - 라이브 스트리밍이나 이벤트 처리에 주로 사용

+ 소비자 그룹
    - 레디스 소비자 그룹은 여러 소비자가 협력하여 스트림의 메시지를 분산 처리하는 방법
    - 각 메시지는 그룹 내의 한 소비자에게만 전달되어 중복 처리를 방지
    - 주요 특징
        + 분산 처리 : 여러 소비자가 동일한 스트림을 나누어 처리하여 처리량을 증가시킨다
        + 중복 방지 : 각 메시지는 그룹 내 하나의 소비자에게만 전달
        + 장애 복구 : 소비자가 실패하면 다른 소비자가 해당 메시지를 처리할 수 있다
        + 확인 응답(ACK) : 메시지 처리 완료를 명시적으로 확인
    - xgroup create로 소비자 그룹을 생성할 수 있다
        ```bash
        XGROUP CREATE mystream mygroup $ MKSTREAM
        ```
    - xreadgroup으로 메시지를 읽을 수 있다
        ```bash
        XREADGROUP GROUP mygroup consumer1 COUNT 1 STREAMS mystream >
        ```
    - xack : 메시지 처리 완료를 확인
        ```bash
        XACK mystream mygroup 1634567890123-0
        ```
    - xpending : 처리 대기 중인 메시지를 조회(보류 리스트)
        + 소비자 그룹에서 전달되었지만 아직 ack되지않은 메시지를 추적하는 레디스 내부 자료구조
        + 메시지의 안정적인 처리와 장애 복구를 위해 사용
        + 보류 리스트의 역할
            - 추적 관리 : 전달된 모든 메시지의 상태 추적
            - 장애 감지 : 오래된 보류 메시지로 장애 상황 파악
            - 복구 지원 : xclaim으로 메시지 재할당 가능

        ```bash
        # 보류 리스트 조회
        xpending mystream mygroup

        # 최대 10개의 보류 리스트를 조회
        xpending mystream mygroup - + 10

        # 메시지 재할당
        xclaim mystream mygroup new-consumer 3600000 1634567890123-0

        # 메시지 자동 재할당
        xautoclaim mystream mygroup new-consumer 3600000 0-0
        ```
    - ack : 확인 응답
        + 소비자가 메시지를 성공적으로 처리했음을 레디스에 알리는 확인 응답
        + 소비자가 메시지를 읽고 처리가 완료되면 반드시 ack를 보내야 함
            - 메시지 전달 : xreadgroup으로 메시지가 소비자에게 전달
            - 보류 리스트 등록 : 전달된 메시지가 자동으로 보류 리스트에 추가
            - 메시지 처리 : 소비자가 비즈니스 로직 수행
            - ACK 전송 : 처리 완료 후, xack 명령으로 확인
            - 보류 리스트 제거 : ack된 메시지가 보류 리스트에서 제거
        + ack의 중요성
            - 데이터 무결성 : 메시지가 확실하게 처리되었음을 보장
            - 중복 방지 : ack되지 않은 메시지는 다시 처리 가능
            - 장애 복구 : 소비자 장애 시 다른 소비자가 처리 가능
    - last_delivered_id
        + 레디스 소비자 그룹이 `가장 마지막에 전달한 메시지의 ID`를 추적하는 포인터
            - 소비자 그룹 차원에서 관리되며 개별 소비자의 ack와는 별개
        + 전달 시점에 업데이트
            - xreadgroup 명령으로 메시지를 읽을 때마다 업데이트
            - ack 여부와는 `완전히 무관`
            - 소비자 그룹 차원에서 `어디까지 전달했는가`를 추적

        |구분|last_delivered_id|보류 리스트(ack)|
        |---|---|---|
        |레벨|그룹 차원|소비자 차원|
        |목적|다음 읽기 시작점|처리 완료 추적|
        |업데이트 시점|메시지 전달 시|ack 처리 시|
        |영향|새 메시지 읽기 범위|재처리 대상 결정|

        + 시나리오
            - 상황 : 메시지 5개 있는 스트림
                + consumer가 3개 읽음 > last_delivered_id 3으로 업데이트
                + 1, 2번 메시지 ack > 보류 리스트에는 3번 메시지
                + xreadgroup 호출 > 4, 5번 메시지부터 읽기 시작
        + 장애복구에서 활용
            ```bash
            // 특정 ID부터 다시 읽고 싶을 때
            xreadgroup group mygroup consumer1 STREAMS mystream 1634567890123-0

            // 보류 중인 메시지부터 읽고 싶을 때  
            xreadgroup group mygroup consumer1 STREAMS mystream 0
            ```

+ 레디스 스트림의 보증전략
    - 메시지 전달과 처리에 대해 서로 다른 보증 수준을 제공하는 3가지 전략이 있음
    - At-Most-Once (최대 한번)
        + 소비자는 메시지를 받자마자 ack를 보낸다
            - 메시지를 받자마자 ack를 보내므로 중복 가능성 X
        + 장점
            - 높은 성능과 처리량
            - 구현이 단순함
            - 중복 처리 걱정 없음
        + 단점
            - 처리 실패시 메시지 영구 손실
            - 장애 복구 불가능
        + 왜 중복 처리가 없는가
            - 메시지 읽기 > 즉시 ack > 비즈니스 로직 처리 순서로 처리되기 때문에 한번 읽은 메시지는 다시 읽을 수 없다
            - 레디스에서 ack를 받는 순간 보류 리스트에서 메시지를 제거 > 메시지가 성공적으로 처리

        ```bash
        // 메시지 읽자마자 ACK
        StreamEntry entry = readMessage();
        jedis.xack(stream, group, entry.getID()); // 즉시 ACK
        processMessage(entry); // 처리 실패해도 이미 ACK됨
        ```
    - At-Least-Once (최소 한번)
        + 소비자는 받은 메시지를 모두 처리한 후, ack를 보낸다
        + 받은 메시지를 처리하던 중, 소비자가 종료되는 상황이 발생 > ack를 전송하지 않았으므로 보류 리스트로 이동 > 메시지를 한번 더 발송
        + 장점
            - 메시지 손실 없음
            - 장애 복구 가능
            - 레디스 기본 매커니즘 활용
        + 단점
            - 중복 처리 가능성
            - 멱등성 구현 필요
        + 메시지 손실없음의 의미
            - 메시지를 읽는 순간 보류 리스트에 자동으로 등록, ack를 받을 때까지 계속 추적
                ```bash
                // 메시지 읽기 → 자동으로 보류 리스트 등록
                StreamEntry message = jedis.xreadGroup(group, consumer, ...);
                // 이 시점에서 메시지가 보류 리스트에 들어감

                // 처리 실패 → ACK 안함 → 보류 리스트에 계속 남음
                // 처리 성공 → ACK 함 → 보류 리스트에서 제거
                ```
            - 시나리오별 손실 방지
                + 처리 실패시 : ack 전송 X > 보류 리스트에 존재 > 재처리
                + 소비자 장애시 : 다른 소비자가 xclaim으로 인수 > 재처리
                + 네트워크 장애시 : 연결 복구 후, 보류 메시지 재처리
            - 결국 모든 메시지는 성공적으로 처리된다

        ```bash
        // 처리 완료 후에만 ACK
        StreamEntry entry = readMessage();
        try {
            processMessage(entry); // 먼저 처리
            jedis.xack(stream, group, entry.getID()); // 성공 시에만 ACK
        } catch (Exception e) {
            // ACK 안함 → 재처리됨
        }
        ```
    - Exactly-Once (정확히 한번)
        + 중복 체크 + 트랜잭션
        + 장점
            - 완벽환 정확성 보장
            - 메시지 손실/중복 없음
            - 금융권 등 미션 크리티컬한 시스템에 적합
        + 단점
            - 구현 복잡도 높음
            - 성능 오버헤드
            - 추가 저장소 필요(중복 체크용) 

        ```bash
        // 중복 체크와 처리를 원자적으로
        Transaction tx = jedis.multi();
        if (!isProcessed(messageId)) {
            processMessage(entry);
            tx.sadd("processed", messageId);
            tx.xack(stream, group, entry.getID());
            tx.exec(); // 원자적 실행
        }
        ```

    |시나리오|권장 전략|이유|
    |---|---|---|
    |로그 수집|at-most-once|일부 손실 허용, 높은 처리량 필요|
    |이메일 알림|at-least-once|누락 금지, 중복 발송은 큰 문제 X|
    |결제 처리|exactly-once|중복 결제/누락 모두 치명적|
    |채팅 메시지|at-least-once|누락보다는 중복이 나음|
    |재고 업데이트|exactly-once|정확한 재고 수량 필수|