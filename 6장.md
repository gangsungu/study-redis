## 레디스를 메시지 브로커로 사용하기

### 메시지 브로커의 핵심 역할
+ 최근 서비스 아키텍처는 여러 모듈이 서로 느슨하고 적절하게 연결시킨 구조를 선호
    - 이러한 구조는 다양한 장점이 있지만 모듈간 서로 상호 작용이 필요하므로 메시지 브로커를 필요로 함
+ 서비스 간 커넥션이 실패하는 상황은 언제나 발생가능
    - 따라서 모듈 간 통신은 비동기 통신을 사용하는 것을 권장한다
    - 서비스 간 통신이 불가능한 상황이 바로 장애로 이어지지 않도록 하고
    - 당장 메시지를 처리하지 못하더라도 메시지를 어딘가에 저장 후, 나중에 처리할 수 있는 채널을 만드는 것
    > `메시지 브로커의 핵심역할`

### 메시징 큐와 이벤트 스트림
+ 메시징 큐
    - 애플리케이션 간에 비동기적으로 메시지를 전달하는 통신패턴
    - 레디스에서는 주로 List와 Pub/Sub 기능을 활용

    ```java
    // 메시지 생성자
    import redis.clients.jedis.Jedis;
    import com.fasterxml.jackson.databind.ObjectMapper;

    public class MessageProducer {
        private Jedis jedis;
        private ObjectMapper objectMapper;
        
        public MessageProducer() {
            this.jedis = new Jedis("localhost", 6379);
            this.objectMapper = new ObjectMapper();
        }
        
        public void sendMessage(String queueName, Object message) {
            try {
                String jsonMessage = objectMapper.writeValueAsString(message);
                jedis.lpush(queueName, jsonMessage);
                System.out.println("메시지 전송: " + jsonMessage);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }

    // 메시지 소비자
    public class MessageConsumer {
        private Jedis jedis;
        private ObjectMapper objectMapper;
        
        public MessageConsumer() {
            this.jedis = new Jedis("localhost", 6379);
            this.objectMapper = new ObjectMapper();
        }
        
        public void consumeMessages(String queueName) {
            while (true) {
                try {
                    // 블로킹 방식으로 메시지 대기 (5초 타임아웃)
                    List<String> messages = jedis.brpop(5, queueName);
                    if (messages != null && messages.size() > 1) {
                        String message = messages.get(1);
                        processMessage(message);
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }
        
        private void processMessage(String message) {
            System.out.println("메시지 처리: " + message);
            // 비즈니스 로직 처리
        }
    }
    ```

+ 이벤트 스트림
    - 시간 순서대로 발생하는 이벤트들의 연속된 흐름
    - 레디스에서는 Redis Stream을 사용하여 구현

    ```java
    // 이벤트 생산자
    import redis.clients.jedis.StreamEntryID;
    import java.util.HashMap;
    import java.util.Map;

    public class EventStreamProducer {
        private Jedis jedis;
        
        public EventStreamProducer() {
            this.jedis = new Jedis("localhost", 6379);
        }
        
        public void publishEvent(String streamName, Map<String, String> eventData) {
            try {
                // 자동으로 ID 생성하여 스트림에 이벤트 추가
                StreamEntryID id = jedis.xadd(streamName, StreamEntryID.NEW_ENTRY, eventData);
                System.out.println("이벤트 발행됨 - ID: " + id);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        
        public void publishUserEvent(String userId, String eventType, String data) {
            Map<String, String> eventData = new HashMap<>();
            eventData.put("userId", userId);
            eventData.put("eventType", eventType);
            eventData.put("data", data);
            eventData.put("timestamp", String.valueOf(System.currentTimeMillis()));
            
            publishEvent("user-events", eventData);
        }
    }

    // 이벤트 소비자
    import redis.clients.jedis.StreamEntry;
    import redis.clients.jedis.StreamEntryID;
    import redis.clients.jedis.params.XReadGroupParams;
    import java.util.List;
    import java.util.Map;

    public class EventStreamConsumer {
        private Jedis jedis;
        private String consumerGroup;
        private String consumerName;
        
        public EventStreamConsumer(String consumerGroup, String consumerName) {
            this.jedis = new Jedis("localhost", 6379);
            this.consumerGroup = consumerGroup;
            this.consumerName = consumerName;
        }
        
        public void createConsumerGroup(String streamName) {
            try {
                // 컨슈머 그룹 생성 (스트림 시작부터 읽기)
                jedis.xgroupCreate(streamName, consumerGroup, new StreamEntryID(), false);
            } catch (Exception e) {
                // 이미 존재하는 그룹일 경우 무시
                System.out.println("컨슈머 그룹이 이미 존재합니다.");
            }
        }
        
        public void consumeEvents(String streamName) {
            createConsumerGroup(streamName);
            
            while (true) {
                try {
                    // 컨슈머 그룹으로부터 메시지 읽기
                    Map<String, List<StreamEntry>> result = jedis.xreadGroup(
                        consumerGroup,
                        consumerName,
                        XReadGroupParams.xReadGroupParams().block(1000).count(10),
                        Map.of(streamName, StreamEntryID.UNRECEIVED_ENTRY)
                    );
                    
                    if (result != null && !result.isEmpty()) {
                        List<StreamEntry> entries = result.get(streamName);
                        for (StreamEntry entry : entries) {
                            processEvent(streamName, entry);
                            // 메시지 처리 완료 확인
                            jedis.xack(streamName, consumerGroup, entry.getID());
                        }
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                    try {
                        Thread.sleep(1000);
                    } catch (InterruptedException ie) {
                        Thread.currentThread().interrupt();
                        break;
                    }
                }
            }
        }
        
        private void processEvent(String streamName, StreamEntry entry) {
            System.out.println("이벤트 처리 - Stream: " + streamName + 
                            ", ID: " + entry.getID() + 
                            ", Data: " + entry.getFields());
            // 비즈니스 로직 처리
        }
    }

    public class EventStreamExample {
        public static void main(String[] args) {
            // Producer 사용
            EventStreamProducer producer = new EventStreamProducer();
            producer.publishUserEvent("user123", "login", "successful");
            producer.publishUserEvent("user456", "purchase", "product-abc");
            
            // Consumer 사용
            EventStreamConsumer consumer = new EventStreamConsumer("analytics-group", "consumer-1");
            
            // 별도 스레드에서 이벤트 소비
            new Thread(() -> consumer.consumeEvents("user-events")).start();
        }
    }
    ```

+ 주요 차이점
    - 메시지 큐의 특징
        + 일대일 통신(한 메시지는 한 사용자가 처리, 큐 자료구조를 생각하자)
        + 메시지가 소비되면 큐에서 제거됨
            - 나중에 추가된 사용자가 이전 메시지를 처리할 수 없음
        + 간단한 작업 분산에 적합
    - 이벤트 스트림의 특징
        + 일대다 통신 가능(여러 소비자가 같은 이벤트 처리)
        + 이벤트가 스트림에 영구 저장
            - 나중에 추가된 사용자도 이벤트 순서에 따라 처리가능
        + 시간 순서 보장

### 메시지 발행하기
+ publish 커맨드를 사용해 메시지를 전파할 수 있다
    ```bash
    publish hello world
    ```
    - publish 커맨드를 사용하면 hello 채널을 수신하고 있는 모든 서버에게 world라는 메시지가 전파된다
    - 메시지 전파 후에는 메시지를 수신한 구독자 수가 반환된다

+ subscribe 커맨드를 사용해서 채널을 구독할 수 있다
    ```bash
    subscribe event1 event2
    ```
    - subscribe 커맨드를 사용하면 입력한 채널을 구독할 수 있다
    - 클라이언트가 구독자로 동작할 때, 새로운 채널을 구독할 수 있지만 pub/sub와 관련되지 않은 다른 커맨드는 실행할 수 없다
        + 클라이언트가 `구독 모드`로 전환
        + 왜 이런 제한이 있을까?
            - 프로토콜 설계 관점 : 레디스 pub/sub는 `push 방식`으로 동작, 서버가 구독자에게 지속적으로 메시지를 푸시하는 상태에서는 일반적인 요청-응답 패턴을 사용할 수 없다
            - 연결상태 관리 : 구독 모드에서는 클라이언트가 `듣기 대기` 상태가 되어 서버로부터 오는 메시지를 받기 위해 연결을 점유
            - 동시성 문제 방지 : 메시지 수신과 일반 명령 실행이 동시에 일어나면 응답을 구분하기 어려워짐
        + 이런 제약은 레디스가 싱글 스레드로 동작하기 때문에?
            - 레디스는 6.0부터 멀티 스레드를 지원하지만 구독 모드 제약은 동일
            - 진짜 이유는 `네트워크 프로토콜의 설계`
                + 하나의 TCP 연결에서 두가지 다른 통신 패턴을 동시에 처리할 수 없다

                ```bash
                // 일반 명령 : 요청-응답 패턴
                Client -> Server: GET mykey
                Client <- Server: "myvalue"

                Client -> Server: SET anotherkey "value"  
                Client <- Server: OK

                // Pub/Sub : 비동기 푸시 패턴
                Client -> Server: SUBSCRIBE mychannel
                Client <- Server: 구독 확인 메시지

                # 이후 언제든지 서버가 푸시
                Client <- Server: 메시지1
                Client <- Server: 메시지2
                Client <- Server: 메시지3
                ```

            - 아파치 카프카와 RabbitMQ와 같은 전용 메시징 시스템도 비슷한 제약이 존재
            > 레디스의 싱글 스레드 특성보다는 **네트워크 프로토콜의 본질적인 제약**으로 보는 것이 더 정확
    - psubscribe 커맨드를 사용하면 일치하는 패턴에 해당하는 모든 채널을 구독할 수 있다
        + psubscribe 커맨드는 pmessage 타입으로 메시지를 전달받으며 pmessage는 message 타입에서 `패턴` 정보가 추가된 형태

        ```
        message: 3개 필드 (메시지타입, 채널명, 내용)
        pmessage: 4개 필드 (메시지타입, 패턴, 실제채널명, 내용)
        ```

### 클러스터 구조의 Pub/Sub
+ 레디스 클러스터에서 Pub/Sub은 단일 레디스 인스턴스와 다른 특성을 가진다
    - 전체 클러스터 브로드 캐스트
        + 레디스 클러스터에서 메시지를 발행하면 클러스터에 속한 `모든 노드`에 브로드캐스트된다
            - 단일 인스턴스
                + 모든 구독자가 같은 서버에 연결
                + 메시지를 발행하면 서버의 모든 구독자가 수신
            - 클러스터
                + 구독자들이 여러 노드에 분산되어 있음
                + 메시지를 발행하면 모든 구독자가 수신해야 함
                + 따라서 모든 노드에 브로드캐스트 진행

        |환경|키-값 데이터|Pub/Sub 데이터|
        |---|---|---|
        |단일 인스턴스|하나의 서버에 저장|하나의 서버에서 처리|
        |클러스터|샤딩으로 분산 저장|모든 노드에 브로드캐스트|

### 레디스 list를 메시징 큐로 사용하기
+ 자료구조 list는 메시징 큐로 사용하기 적절한 자료구조다
    - 큐의 tail과 head에서 데이터를 넣고 뺄 수 있는 lpush, lpop, rpush, rpop 등의 커맨드가 존재하기 때문

+ list의 ex 옵션
    - 타임라인 캐시에 데이터를 저장한다고 가정할 때, rpushx 커맨드를 사용할 수 있다
    - rpushx는 데이터를 저장하고자 하는 list가 존재할 때, 데이터를 추가하는 커맨드
    - 해당 커맨드로 캐시를 관리하면 이미 캐시된(키가 존재하는) 타임라인에만 데이터를 추가할 수 있다
        + 타임라인 캐시가 저장되지 않은 유저는 타임라인 캐시 데이터를 관리할 필요가 없기 때문

+ list의 블로킹 기능
    - 폴링
        + 폴링은 서버나 시스템이 새 데이터가 추가되었는지 주기적으로 확인하는 방식
        + 장점
            - 구현이 단순하다
            - 시스템이 스스로 제어가 가능하다(언제 요청할지)
        + 단점
            - 리소스 낭비(주기적으로 확인하므로)
            - 데이터가 없어도 무의미한 요청을 반복할 수 있다
            - 실시간성이 떨어진다(데이터가 추가되어도 확인주기가 아니면 이벤트 진행 불가)
    
    - 블로킹
        + 데이터가 없으면 잠깐 멈추고 기다렸다가 데이터가 추가되면 바로 응답하는 방식
        + 장점
            - 데이터가 추가되면 동작하므로 대기 리소스를 줄일 수 있음
            - 실시간성이 높음
        + 단점
            - 클라이언트가 `대기상태`가 됨
            - 타임아웃 설정에 따라 무한정 대기하는 상태가 될 수 있다

### Stream
+ 스트림은 대용량, 대규모의 메시징 데이터를 빠르게 처리할 수 있도록 설계된 자료구조
+ 레디스에서는 하나의 스트림 자료구조가 하나의 스트림을 의미한다
    - 레디스 스트림에서 각 메시지는 시간과 관련된 유니크한 ID를 가지며 중복되지 않는다
    - ID는 다음과 같이 두개의 파트로 나뉜다
        ```bash
        <millisecondsTime>-<sequenceNumber>
        ```
