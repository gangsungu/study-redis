## 레디스 기본개념

### 레디스의 자료구조
+ string
    - 레디스에서 데이터를 저장할 수 있는 가장 간단한 구조
    - 최대 512MB의 데이터를 저장가능
    - 이진 데이터를 포함하는 모든 종류의 문자열을 binary-safe하게 처리되기 때문에 JPEG와 같은 바이트 값, HTTP 응답값 등 다양한 데이터를 저장하는 것도 가능하다
    - set 커맨드는 string 데이터를 저장하며 get 커맨드는 저장된 string 데이터를 조회할 수 있다

        ```bash
        127.0.0.1:6379> set hello world
        OK
        127.0.0.1:6379> get hello
        "world"
        ```

    - set과 함께 nx 옵션을 사용하면 저장된 키가 없을때만 새로운 키를 저장한다

        ```bash
        127.0.0.1:6379> set gello newval nx
        OK
        ```

    - xx 옵션을 사용하면 반대로 키가 이미 있을때만 새로운 값으로 덮어쓰며 새로운 키를 생성하지 않는다

        ```bash
        127.0.0.1:6379> set hello newval xx
        OK
        127.0.0.1:6379> get hello
        "newval"
        ```

    - string 자료 구조는 모든 문자열 데이터를 저장할 수 있으므로 숫자 형태의 데이터를 저장하는 것도 가능
    - incr, incrby와 같은 커맨드를 사용하면 자료 구조에 저장된 숫자를 `원자적`으로 조작할 수 있다
        + decr, decrby 커맨드는 동일한 방식으로 데이터를 감소시키는 커맨드
        + 원자적이라는 것은 같은 키에 접근하는 여러 클라이언트가 경쟁 상태를 발생시킬 일이 없음을 뜻함

        ```bash
        127.0.0.1:6379> set counter 100
        OK
        127.0.0.1:6379> incr counter
        (integer) 101
        127.0.0.1:6379> incrby counter 50
        (integer) 151
        ```

    - mset, mget 커맨드는 한번에 여러 키를 조작할 수 있다
        ```bash
        127.0.0.1:6379> mset a 10 b 20 c 30
        OK
        127.0.0.1:6379> mget a b c
        1) "10"
        2) "20"
        3) "30"
        ```

+ list
    - 레디스에서 list는 순서를 가지는 문자열 목록
    - 하나의 list에는 최대 42억 개의 데이터를 저장할 수 있다
    - 다른 배열처럼 인덱스를 이용해 데이터에 직접 접근이 가능하며 스택과 큐로 사용된다
    - lpush 커맨드는 list의 왼쪽에 데이터를 추가하며 rpush는 list의 오른쪽에 데이터를 추가한다
        ```bash
        127.0.0.1:6379> lpush mylist e
        (integer) 1
        127.0.0.1:6379> rpush mylist b
        (integer) 2
        127.0.0.1:6379> lpush mylist b a c b a
        (integer) 7
        ```
    - lrange 커맨드를 사용하면 list에 들어있는 데이터를 조회할 수 있다
        + lrange는 양 끝의 아이템의 인덱스를 각각 인수로 받는다
        + 인덱스는 음수가 가능하며 가장 오른쪽 끝의 인덱스는 -1부터 순서대로 -2, -3이다
        + 인수로 0 -1을 입력하면 전체 데이터를 출력하라는 의미를 갖는다
        ```bash
        127.0.0.1:6379> lrange mylist 0 -1
        1) "a"
        2) "b"
        3) "c"
        4) "a"
        5) "b"
        6) "e"
        7) "b"

        127.0.0.1:6379> lrange mylist 0 -7
        1) "a"
        127.0.0.1:6379> lrange mylist 0 -8
        (empty array)
        127.0.0.1:6379> lrange mylist 0 -6
        1) "a"
        2) "b"
        ```
    - lpop 커맨드는 list에 저장된 첫번째 아이템을 반환하는 동시에 삭제한다, 숫자와 함께 사용하면 지정된 숫자만큼의 아이템을 반환한다
        ```bash
        127.0.0.1:6379> lpop mylist
        "a"
        127.0.0.1:6379> lpop mylist 2
        1) "b"
        2) "c"
        127.0.0.1:6379> lrange mylist 0 -1
        1) "a"
        2) "b"
        3) "e"
        4) "b"
        ```
    - ltrim 커맨드는 시작과 끝 아이템의 인덱스를 전달받아 지정된 범위에 속하지 않은 아이템은 모두 삭제하지만 lpop처럼 아이템을 반환하지 않는다
        ```bash
        127.0.0.1:6379> lrange mylist 0 -1
        1) "a"
        2) "b"
        3) "e"
        4) "b"
        127.0.0.1:6379> ltrim mylist 0 1
        OK
        127.0.0.1:6379> lrange mylist 0 -1
        1) "a"
        2) "b"
        ```
        + lpush와 ltrim 커맨드를 함께 사용하면 고정된 길이의 큐를 유지할 수 있다
            ```bash
            lpush logdata <data>
            ltrim logdata 0 999
            # 데이터가 1001개가 되기 전까지는 1000번 인덱스가 없으므로 ltrim이 동작하지 않는다
            # 데이터가 1001개가 되면 ltrim이 1000번 인덱스, 가장 처음 들어온 값을 삭제한다
            ```
    - list 양 끝에 데이터를 넣고 빼는 lpush, rpush, lpop, rpop 커맨드는 O(1)의 복잡도를 가진다
    - 하지만 인덱스나 데이터를 이용해 list의 중간 데이터에 접근할 때는 O(n)의 복잡도를 가진다

    + linsert 커맨드는 before, after의 옵션을 사용하여 원하는 데이터의 앞이나 뒤에 데이터를 추가할 수 있다
        - 지정한 데이터가 없으면 오류를 반환
            ```bash
            127.0.0.1:6379> lrange mylist 0 -1
            1) "a"
            2) "b"
            127.0.0.1:6379> linsert mylist before b e
            (integer) 3
            127.0.0.1:6379> lrange mylist 0 -1
            1) "a"
            2) "e"
            3) "b"
            ```

    + lset 커맨드는 지정한 데이터를 신규 입력하는 형태로 데이터를 덮어쓴다
        - list의 범위를 벗어나는 데이터를 입력하면 오류를 반환
            ```bash
            127.0.0.1:6379> lset mylist 2 f
            OK
            127.0.0.1:6379> lrange mylist 0 -1
            1) "a"
            2) "e"
            3) "f"
            ```

    + lindex 커맨드는 원하는 인덱스의 데이터를 확인가능
        ```bash
        127.0.0.1:6379> lindex mylist 3
        (nil)
        127.0.0.1:6379> lindex mylist 2
        "f"
        ```

+ hash
    - 레디스에서 hash는 필드-값 쌍을 가진 아이템의 집합
    - hash는 객체를 표현하기 적절한 자료구조이므로 관계형 데이터베이스의 테이블 데이터로 변환하는 것도 간편
    - 칼럼이 고정된 관계형 데이터베이스와 달리 hash에서 필드를 추가하는 것은 간단하다
        + hash는 각 아이템마다 다른 필드를 가질 수 있으며 동적으로 다양한 필드를 추가할 수 있다
    - hset 커맨드를 사용하여 hash에 아이템을 저장할 수 있으며 한번에 여러 필드-값 쌍을 저장할 수 있다

        ```bash
        127.0.0.1:6379> hset product:123 name "happy hacking"
        (integer) 1
        127.0.0.1:6379> hset product:123 typeid 35
        (integer) 1
        127.0.0.1:6379> hset product:123 version 2002
        (integer) 1
        127.0.0.1:6379> hset product:123 name "track ball" typeid 32
        (integer) 0
        127.0.0.1:6379> hset product:234 name "track ball" typeid 32
        (integer) 2
        ```

    - hash에 저장된 데이터는 hget으로 가져올 수 있으며 이때는 hash의 자료구조의 키와 아이템의 필드를 입력해야 한다
        + hmget 커맨드를 사용하면 하나의 hash 내에서 다양한 필드의 값을 가져올 수 있다
        + hgetall 커맨드는 hash 내의 모든 필드-값 쌍을 차례로 반환한다

            ```bash
            127.0.0.1:6379> hgetall product:123
            1) "name"
            2) "track ball"
            3) "typeid"
            4) "32"
            5) "version"
            6) "2002"
            ```

+ set
    - 레디스에서 set은 정렬되지 않은 문자열의 모음
    - 아이템은 중복되어 저장되지 않으며 교집합, 합집합, 차집합 등 집합 연산 커맨드를 제공한다
    - sadd 커맨드를 사용하여 set에 아이템을 저장할 수 있으며 한번에 여러개의 아이템을 저장하는 것도 가능하다
        ```bash
        127.0.0.1:6379> sadd myset a
        (integer) 1
        127.0.0.1:6379> sadd myset a a a n c b e
        (integer) 4

        # sadd 커맨드는 저장되는 실제 아이템 수를 반환
        # 중복된 값을 허용하지 않으므로 실제로 저장된 아이템 수인 4를 반환한다
        ```

    - smembers 커맨드는 저장된 순서와 관계없이 set 자료구조에 저장된 전체 아이템을 출력한다
        ```bash
        127.0.0.1:6379> smembers myset
        1) "a"
        2) "n"
        3) "c"
        4) "b"
        5) "e"
        ```

    - srem 커맨드를 사용하면 set에서 원하는 데이터를 삭제할 수 있으며 spop 커맨드는 내부 아이템 중 랜덤으로 하나의 아이템을 반환하는 동시에 해당 아이템을 삭제한다
        ```bash
        127.0.0.1:6379> srem myset b
        (integer) 1
        127.0.0.1:6379> spop myset
        "a"
        127.0.0.1:6379> smembers myset
        1) "n"
        2) "c"
        3) "e"
        ```

    - set에서 합집합은 sunion, 교집합은 sinter, 차집합은 sdiff 커맨드로 실행할 수 있다
        ```bash
        127.0.0.1:6379> sadd set:111 a b c d e
        (integer) 5
        127.0.0.1:6379> sadd set:222 d e f g h
        (integer) 5
        127.0.0.1:6379> sinter set:111 set:222
        1) "d"
        2) "e"
        127.0.0.1:6379> sunion set:111 set:222
        1) "a"
        2) "b"
        3) "c"
        4) "d"
        5) "e"
        6) "f"
        7) "g"
        8) "h"
        127.0.0.1:6379> sdiff set:111 set:222
        1) "a"
        2) "b"
        3) "c"
        ```

+ sorted set
    - 레디스에서 sorted set은 score 값에 따라 정렬되는 고유한 문자열의 집합
    - 모든 아이템은 스코어-값 쌍을 가지며 저장될 때 스코어 값으로 정렬되어 저장된다
        + 인덱스 사용가능
    - 데이터는 중복없이 유일하게 저장되므로 set과 유사
    - 각 아이템은 스코어에 연결되어 있어 hash와 유사
    - zadd 커맨드를 사용하면 sorted set에 아이템을 저장할 수 있으며 스코어-값 쌍으로 입력해야 한다
        + 각 아이템은 sorted set에 저장되는 동시에 score 값으로 정렬
        + 저장하려는 데이터가 sorted set에 존재하면 스코어만 업데이트, 업데이트된 스코어로 아이템이 재정렬된다
        + 지정된 키가 없으면 sorted set 자료구조를 새로 생성
        + 키가 존재하지만 sorted set 자료구조가 아닌 경우, 오류를 반환한다
        ```bash
        127.0.0.1:6379> zadd score:250815 100 user:b
        (integer) 1
        ```
        + zadd 커맨드는 다양한 옵션을 지원
            - xx : 아이템이 이미 존재할 때만 스코어를 업데이트
            - nx : 아이템이 존재하지 않을 때만 신규로 추가, 기존 스코어를 업데이트 하지 않음
            - lt : 업데이트하려는 스코어가 기존보다 작을 경우만 업데이트, 아이템이 존재하지 않는 경우 새로운 데이터를 삽입
            - gt : 업데이트하려는 스코어가 기존보다 클 경우만 업데이트, 역시 아이템이 존재하지 않으면 새로운 데이터를 삽입
        + zrange 커맨드를 사용하면 sorted set에 저장된 데이터를 조회할 수 있다
            - start, stop으로 범위를 항상 지정해야한다
            - withscores 옵션으로 score 값도 함께 출력가능
            - rev로 스코어 값의 역순으로 출력가능
                ```bash
                127.0.0.1:6379> zrange score:250815 0 -1 withscores
                1) "user:b"
                2) "100"
                ```
            - byscore 옵션으로 start, stop를 인자로 사용하는 최대, 최소 범위의 스코어를 탐색가능
                + 인수로 전달하는 스코어에 (문자를 추가하면 해당 스코어를 포함하지 않는 값만 탐색가능
                    ```bash
                    127.0.0.1:6379> zrange score:250815 100 150 withscores byscore
                    1) "user:b"
                    2) "100"
                    127.0.0.1:6379> zrange score:250815 50 75 withscores byscore
                    (empty array)
                    127.0.0.1:6379> zrange score:250815 (100 150 withscores byscore
                    (empty array)
                    ```
                + 스코어의 최소, 최대값을 표현하기 위해 -inf, +inf 값을 사용한다
                    ```bash
                    127.0.0.1:6379> zrange score:250815 150 +inf byscore withscores
                    1) "user:a"
                    2) "150"
                    3) "user:c"
                    4) "300"

                    # rev 옵션도 사용가능한데, 최소, 최대값 전달 순서는 변경해야한다
                    127.0.0.1:6379> zrange score:250815 150 +inf byscore withscores rev
                    (empty array)
                    127.0.0.1:6379> zrange score:250815 +inf 150  byscore withscores rev
                    1) "user:c"
                    2) "300"
                    3) "user:a"
                    4) "150"
                    ```
    - sorted sort에 데이터를 저장할 때, 스코어가 같으면 데이터는 사전 순으로 정렬한다
        + bylex 옵션을 사용하면 사전식 특성을 활용하여 특정 아이템 조회가 가능하다
            ```bash
            # 특수 기호들
            ZRANGE key - +          # 전체 범위 (처음부터 끝까지)
            ZRANGE key [a [z        # 'a'부터 'z'까지 (포함)
            ZRANGE key (a (z        # 'a'와 'z' 제외하고 그 사이
            ZRANGE key [apple [banana # 'apple'부터 'banana'까지
            ```

+ 비트맵
    - 비트맵은 독자적인 자료구조가 아닌 string 자료구조에 bit 연산을 수행할 수 있도록 확장한 형태
    - string 자료구조가 binary safe하고 최대 512MB까지 저장이 가능하므로 2<sup>32</sup>의 비트를 가지고 있는 비트맵 형태라고 볼 수 있다
    - setbit로 비트를 저장할 수 있으며 getbit로 비트를 조회할 수 있다, 한번에 비트를 조회하려면 bitfield를 사용하면 된다
        ```bash
        127.0.0.1:6379> setbit mybitmap 2 1
        (integer) 0
        127.0.0.1:6379> getbit mybitmap 2
        (integer) 1
        127.0.0.1:6379> bitfield mybitmap set u1 6 1 set u1 10 1 set u1 14 1
        1) (integer) 0
        2) (integer) 0
        3) (integer) 0
        127.0.0.1:6379> bitcount mybitmap
        (integer) 4
        ```

+ hyperlog
    - hyperlog는 집합의 카디널리티를 추정할 수 있는 자료구조
    - hyperlog는 입력되는 데이터를 
    

### 키-값과 필드-값의 차이
+ 레디스는 하나의 거대한 키-값 저장소

```bash
# Redis 전체 구조 (키-값)
user:1001 → "John Doe"           # String 타입
scores → [100, 95, 87]           # List 타입  
visited_pages → {1, 5, 10}       # Set 타입
user:profile:1001 → {필드들...}   # Hash 타입
```

+ Hash 타입의 값 안에서 다시 필드-값의 구조를 가짐

```bash
# Hash 내부 구조
HSET user:profile:1001 name "John Doe"
HSET user:profile:1001 age "30" 
HSET user:profile:1001 email "john@example.com"

# 구조적으로 보면:
키: user:profile:1001
값: {
  name → "John Doe",      # 필드-값 쌍
  age → "30",             # 필드-값 쌍  
  email → "john@example.com"  # 필드-값 쌍
}
```

```bash
# 1단계: Redis 전체 구조 (키-값)
┌─────────────────┬───────────────────────┐
│      키         │         값            │
├─────────────────┼───────────────────────┤
│ user:1001       │ "John Doe"            │
│ user:profile:1001│ {name: "John", age: 30}│ ← Hash 타입
│ scores          │ [100, 95, 87]         │
└─────────────────┴───────────────────────┘

# 2단계: Hash 내부 구조 (필드-값)  
user:profile:1001 Hash 내부:
┌─────────┬─────────────────┐
│  필드   │      값         │
├─────────┼─────────────────┤
│ name    │ "John Doe"      │
│ age     │ "30"            │
│ email   │ "john@email.com"│
└─────────┴─────────────────┘
```

### list와 sorted set의 차이
+ list와 sorted set 모두 순서를 갖는 자료구조이므로 인덱스로 데이터에 접근할 수 있다
+ 결론적으로 list의 시간복잡도는 O(n), sorted set의 시간복잡도는 O(log(n))이다
> 시간복잡도에서 차이가 나는 이유는 `내부 자료구조의 차이`

+ list의 내부 구조
    ```bash
    # List는 연결 리스트(Linked List) 또는 압축 리스트로 구현
    ["a"] -> ["b"] -> ["c"] -> ["d"] -> ["e"]
    0       1       2       3       4

    # 특정 인덱스 접근 시 처음부터 순차 탐색
    LINDEX mylist 3  # 0->1->2->3 순차 접근 필요 → O(n)
    ```

+ sorted set의 내부 구조
    ```bash
    # Skip List + Hash Table 조합으로 구현

    Skip List (점프 가능한 다층 구조):
    Level 3: [10] ----------------> [50]
    Level 2: [10] -------> [30] --> [50] 
    Level 1: [10] -> [20] -> [30] -> [40] -> [50]
    Level 0: [10] -> [20] -> [30] -> [40] -> [50]

    # 이진 검색과 비슷하게 빠른 탐색 → O(log n)
    ```

+ 실제 예시
    ```bash
    # 1만개 요소가 있다고 가정

    # List에서 중간 요소 찾기
    LINDEX mylist 5000    # 5000번 순차 접근 필요

    # Sorted Set에서 요소 찾기  
    ZSCORE myset "member5000"  # Skip List로 약 13-14번 점프로 찾기
                            # log₂(10000) ≈ 13.3
    ```

    - skip list의 동작 원리
        ```bash
        # 50 찾기 예시
        # 1. Level 3에서 시작: 10 -> 50 (찾았다!)
        # 2. 만약 45를 찾는다면:
        #    Level 3: 10 -> (50은 너무 큼)
        #    Level 2: 10 -> 30 -> (50은 너무 큼)  
        #    Level 1: 30 -> 40 -> (50은 너무 큼)
        #    Level 0: 40 -> 45 (찾았다!)

        ZADD scores 45 "user45"
        ZSCORE scores "user45"  # Skip List 탐색으로 빠르게 찾기
        ```

+ 결론
    - list : 연결 리스트 > 순차 접근만 가능 > O(n)
    - sorted set : skip list + hash > 점프하며 탐색 > O(log(n))

+ skip list의 확률적 특성
    - skip list는 일부 노드를 건너뛸 수 있는 연결 리스트
    - skip list에서 level은 확률적 알고리즘에 의해 자동으로 결정
        ```bash
        # ZADD 명령어 실행 시 내부 과정
        ZADD myset 100 "Alice"

        # 1. 점수와 멤버로 노드 생성
        # 2. 확률적 알고리즘으로 레벨 결정
        # 3. 해당 레벨들에 노드 삽입
        # 4. 포인터 업데이트

        # 예시 결과 (개념적)
        Level 2: [Alice:100] (25% 확률로 여기까지 올라감)
        Level 1: [Alice:100] (50% 확률로 여기까지)  
        Level 0: [Alice:100] (100% 확률로 반드시 여기는 존재)
        ```

    - 확률 분포
        ```bash
        # 각 레벨에 노드가 존재할 확률
        Level 0: 100%    (모든 노드)
        Level 1: 50%     (절반)
        Level 2: 25%     (1/4)  
        Level 3: 12.5%   (1/8)
        Level 4: 6.25%   (1/16)
        ...

        # 1000개 노드가 있다면 예상 분포:
        Level 0: ~1000개 노드
        Level 1: ~500개 노드
        Level 2: ~250개 노드  
        Level 3: ~125개 노드
        Level 4: ~62개 노드
        ```
    
    - 왜 확률적으로 값을 분류하는가?
        + 재균형 알고리즘이 필요없다
        + 삽입/삭제가 단순함
        + 수학적으로 균형잡힌 구조가 생성

### 레디스에서 키를 관리하는 법
+ 키의 자동 생성과 삭제
    - stream, set, sorted set, hash 등 하나의 키가 여러 아이템을 가지고 있는 자료구조는 키가 알아서 생성되고 삭제된다
    - 키 생성과 삭제의 3가지 공통적인 규칙
        + 키가 존재하지 않을 때, 아이템을 넣으면 자동으로 빈 자료구조를 생성
            ```bash
            127.0.0.1:6379> lpush mylist 1 2 3
            (integer) 3
            ```
            - 저장하고자 하는 키에 다른 자료구조가 생성되어 있을때만 에러를 반환한다
        + 모든 아이템을 삭제하면 키도 자동으로 삭제된다
            - 메모리에서 효율성을 가지는 설계(빈 자료구조들이 메모리를 차지하지 않음)
            - 키 공간 정리(사용하지 않는 키들이 자동으로 정리됨)
            - 일관성(exists 명령어가 실제 데이터 존재 여부와 일치)
            - 단 stream은 예외
                + 다른 자료구조와의 차이점때문인데, 다른 자료구조들은 요소만 저장하지만 stream은 상태와 메타데이터를 가진 로그시스템이기 때문
        + 키가 없는 상태에서 키 삭제, 아이템 삭제, 자료구조 크기 조회 등 읽기 전용 커맨드를 수행하면 에러반환 대신에 빈 키를 반환
            - del은 삭제된 키의 개수를 반환하므로 존재하지 않는 키는 0을 반환함
            - llen은 키의 길이를 반환하므로 존재하지 않는 키는 0을 반환함
            - lpop은 삭제할 키가 없으면 nil

+ 키와 관련된 커맨드
    - 키의 조회
        + exists
            - 키의 존재여부를 확인하는 커맨드, 존재하면 1을 존재하지 않으면 0을 반환
            ```bash
            127.0.0.1:6379> set hello world
            OK
            127.0.0.1:6379> exists hello
            (integer) 1
            127.0.0.1:6379> exists world
            (integer) 0
            ```

        + keys
            - 레디스에 저장된 모든 키를 조회하는 커맨드, 매칭되는 패턴에 해당하는 모든 키의 list를 반환한다(글롭패턴)
            - 레디스는 단일 스레드라 keys로 모든 키를 조회하는 동안 모든 명령어가 멈춘다
            - O(N)의 시간복잡도를 가지므로 키의 개수에 비례해서 실행시간이 증가
            - 매칭되는 모든 키를 메모리에 적재하므로 메모리 부족의 위험

        + scan
            - keys를 대체해 키를 조회할 때, 사용하는 커맨드
            - 커서를 기반으로 특정 범위의 키만 조회할수 있으므로 비교적 안전하다
                + count : count 옵션을 사용하여 반환되는 키의 개수를 조정할 수 있다 하지만 레디스가 몇개의 키를 더 읽는게 메모리상으로 효율적이다 판단하면 count 옵션보다 더 많은 키를 반환하는 경우도 있다
                + match : keys처럼 입력한 패턴에 맞는 키를 조회한다
                    ```bash
                    # 이런 상황이 가능:
                    SCAN 0 MATCH very_rare_pattern* COUNT 10
                    # 1) "512"     ← 다음 커서 (0이 아님)
                    # 2) (empty array)  ← 매칭되는 키 없음

                    # 하지만 스캔은 아직 끝나지 않음 (커서가 0이 아니므로)
                    ```
                + type : 지정한 타입의 키만 조회가능

        + sort
            - list, set, sorted set에서만 사용할 수 있는 커맨드로 키 내부의 아이템을 정렬하여 반환
            - limit : 지정한 수만큼의 데이터 조회 가능
            - asc/desc : 오름차순, 내림차순 정렬순서 변경 가능
            - alpha : 정렬대상이 문자열이면 사전순으로 정렬 가능

        + rename/renamenx
            - 키의 이름을 변경하는 커맨드
            - renamenx 커맨드는 변경할 키가 존재하지 않을 때만 동작

        + copy
            - 지정한 키를 복사할 수 있다
            - 다른 연산과 마찬가지로 원자적으로 실행되어 데이터 일관성을 보장
                ```bash
                COPY source destination [DB destination-db] [REPLACE]

                # String 복사
                SET mykey "hello world"
                COPY mykey newkey
                GET newkey
                # "hello world"

                # 원본은 그대로 유지
                GET mykey  
                # "hello world"
                ```
            - replace로 덮어쓰기 가능
                ```bash
                SET key1 "original"
                SET key2 "existing"

                # 대상 키가 이미 존재하면 실패
                COPY key1 key2
                # (integer) 0  ← 복사 실패

                GET key2
                # "existing"  ← 원래 값 유지
                ```

        + type
            - 지정한 자료구조 타입을 반환
                ```bash
                127.0.0.1:6379> set mystring "hello"
                OK
                127.0.0.1:6379> type mystring
                string
                ```

        + object
            - 내부 구현 세부사항을 반환
            
            |명령어|목적|반환값|예시|
            |---|---|---|---|
            |object encoding|내부 구현 방식|int, raw, ziplist, hashtable||
            |object idletime|마지막 접근 시간|초단위 정수||
            |object freq|접근 빈도|0~255 정수||
            |object refcount|참조 카운트|정수|1|

    - 키의 삭제
        + flushall
            - 레디스에 저장된 모든 키를 삭제
            - sync한 방식으로 동작하므로 모든 데이터가 삭제되기 전에는 다른 응답을 처리할 수 없다
            - async 옵션을 사용하면 flush는 백그라운드로 실행되고 커맨드를 입력했을 때, 존재했던 키만 삭제한다

        + del
            - 키와 키에 저장된 아이템을 삭제한다
            - 커맨드 입력 즉시 완전히 삭제한다(동기식)
                ```bash
                # 단일 키 삭제
                SET mykey "value"
                DEL mykey
                # (integer) 1  ← 삭제된 키 개수

                # 여러 키 동시 삭제
                SET key1 "value1"
                SET key2 "value2"
                SET key3 "value3"
                DEL key1 key2 key3
                # (integer) 3
                ```
            - 동작방식
                + 키를 키스페이스에서 즉시 제거
                + 메모리에서 데이터 구조 해제
                + 모든 메모리 정리 완료 후 응답 반환(즉, 큰 데이터일수록 오래 걸림)

        + unlink
            - 키와 키에 저장된 아이템을 삭제한다(del과 비슷)
            - 비동기식 삭제
                ```bash
                # 사용법은 DEL과 동일
                SET mykey "value"
                UNLINK mykey
                # (integer) 1

                # 여러 키 동시 삭제
                UNLINK key1 key2 key3
                # (integer) 3
                ```
            - 동작방식
                + 키를 키스페이스에서 즉시 제거
                + 메모리 해제는 백그라운드 스레드가 담당
                + 즉시 응답 반환(메모리 정리 여부와 상관없이)

        |특성|del|unlink|
        |---|---|---|
        |삭제 방식|동기식(즉시 완전 삭제)|비동기식(백그라운드 삭제)|
        |응답 시간|데이터 크기에 비례|항상 빠름|
        |메모리 해제|즉시|지연됨|
        |redis 블로킹|큰 데이터 작업시 블로킹|논블로킹|
        |사용 권장|작은 데이터, 즉시 해제가 필요할때|큰 데이터, 응답시간이 중요할때|

    - 키의 만료시간
        + expire
            - 현재 시점부터 N초 후에 만료되도록 설정
                ```bash
                # 기본 사용법
                SET mykey "value"
                EXPIRE mykey 60
                # (integer) 1  ← 성공

                # 60초 후 키 자동 삭제됨
                ```
            - 키가 만료될 시간을 초단위로 설정가능하며 아래 옵션들이 있다
                + nx : 키에 만료시간이 정의되어 있지 않는 경우에 수행
                + xx : 키에 만료시간이 정의되어 있는 경우에 수행
                + gt : 키가 가지고 있는 만료시간보다 새로 입력한 초가 더 클때만 수행
                + lt : 키가 가지고 있는 만료시간보다 새로 입력한 초가 더 작을때 수행

        + expireat
            - 키가 특정 유닉스 타임스탬프에 만료되도록 설정
            - 사용가능한 옵션은 expire와 동일하다

        + expretime
            - 키가 만료될 유닉스 타임스탬프를 반환한다
                ```bash
                SET mykey "value"
                EXPIRE mykey 3600  # 1시간 후 만료

                # 만료 시각의 Unix 타임스탬프
                EXPIRETIME mykey
                # (integer) 1692640123  ← Unix 타임스탬프

                # TTL이 없는 키
                EXPIRETIME permanent_key
                # (integer) -1

                # 존재하지 않는 키  
                EXPIRETIME nonexistent_key
                # (integer) -2
                ```

        + ttl
            - 키의 생존 시간을 초로 반환
                ```bash
                SET mykey "value"
                EXPIRE mykey 100

                # 남은 시간 확인
                TTL mykey
                # (integer) 97  ← 97초 남음

                # 만료된 키
                TTL expired_key
                # (integer) -2  ← 키가 존재하지 않음

                # TTL이 설정되지 않은 키
                SET persistent_key "value"
                TTL persistent_key
                # (integer) -1  ← 영구 보존
                ```