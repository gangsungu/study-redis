## 레디스 데이터 백업 방법

### 레디스에서 데이터를 영구 저장하기
+ 레디스는 인메모리 데이터베이스
    - 따라서 예기치 못한 이유로 레디스 인스턴스가 재시작되면 메모리에 저장된 데이터의 유실가능성 존재
+ 복제와 백업의 차이
    - 복제
        + 레디스를 복제구조로 사용하는 경우, 데이터가 실시간으로 전달되니 백업의 필요성을 느끼지 못할 수도 있다
        + 하지만 데이터가 실시간으로 전달되므로 개발자의 실수, 프로그램 상의 버그로 데이터를 삭제하는 커맨드가 실행되면 되돌릴 수 없다
        + 복제는 가용성을 위한 것
    - 백업
        + 장애 상황에서 데이터의 복구를 위해 필요

+ 레디스는 두가지의 백업 방식을 지원
    - AOF (Append Only File)
        + 클라이언트로부터 받은 SET, DEL, INCR과 같은 커맨드를 텍스트 형태로 파일에 기록(레디스 프로토콜 형태 : RESP)
        + 복구시에는 데이터 변경 커맨드를 순서대로 재실행하여 데이터 복원
        + 데이터베이스 트랜잭션 로그와 유사
        + 동기화 정책
            - always : 모든 명령마다 즉시 디스크에 동기화(최고 안전성, 성능 저하)
            - everysec : 1초마다 동기화(레디스 기본 정책)
            - no : 운영체제가 결정하는 시점에 동기화(성능 우선, 안전성 낮음)
            - 동기화 정책 중 고려사항
                + 디스크 I/O 성능
                + 네트워크 지연 시간
                    - 클라이언트와 레디스 서버 간의 네트워크 지연이 큰 경우, AOF 동기화 정책보다 네트워크 성능이 더 큰 병목이 될 수 있다
                + 복제 환경
                    - 마스터 슬레이브 구조에서는 마스터의 AOF 정책이 전체 시스템의 데이터 일관성에 영향을 미친다
                    - 복제과정
                        + 클라이언트가 마스터에 쓰기 명령 전송
                        + 마스터가 자신의 메모리에 데이터 변경 적용
                        + 마스터가 클라이언트에 결과 응답
                        + 마스터가 슬레이브에게 복제 명령 전송(비동기)
                        + 슬레이브들이 각자의 타이밍에 데이터 적용
                    - AOF 정책이 복제에 미치는 영향
                        + 마스터 장애시 데이터 불일치
                            - 마스터 : AOF everysec, 슬레이브 : AOF everysec
                        
                        ```bash
                        // 시간 순서대로 발생하는 상황
                        public class ReplicationConsistencyIssue {
                            public void demonstrateInconsistency() {
                                // T1: 클라이언트가 마스터에 데이터 쓰기
                                master.set("user:1001", "john_updated");
                                // 마스터는 메모리에만 저장, AOF는 OS에 맡김 (no 정책)
                                
                                // T2: 마스터가 클라이언트에 OK 응답
                                // 클라이언트는 데이터가 안전하게 저장되었다고 인식
                                
                                // T3: 마스터가 슬레이브에 복제 명령 전송 시작
                                // 하지만 아직 슬레이브에 도달하지 않음
                                
                                // T4: 갑작스런 마스터 서버 크래시 발생
                                // 마스터의 메모리 데이터 모두 손실
                                // AOF 파일에는 아직 기록되지 않음 (OS 캐시에만 존재)
                                
                                // T5: 슬레이브를 새로운 마스터로 승격
                                // 하지만 슬레이브는 "user:1001" 업데이트를 받지 못했음
                                // 결과: 클라이언트는 저장되었다고 생각하지만 실제로는 데이터 손실
                            }
                        }
                        ```

                        + 네트워크 연결 끊김
                            - 마스터와 슬레이브 간 네트워크 연결 단절
                            - 마스터 : AOF always, 슬레이브 : 네트워크 단절로 인해 복제 중단

                            ```bash
                            public class NetworkPartitionScenario {
                                public void handlePartitionedWrite() {
                                    // 네트워크 분할 상황에서도 마스터는 계속 쓰기 요청 처리
                                    while (networkPartitioned) {
                                        // 마스터는 AOF에 모든 변경사항 기록
                                        master.set("session:active", "user_data");  // AOF에 안전하게 저장
                                        
                                        // 하지만 슬레이브는 이 변경사항을 받지 못함
                                        // 슬레이브에서 읽기 작업 시 오래된 데이터 반환
                                    }
                                    
                                    // 네트워크 복구 후 대량의 복제 데이터가 한 번에 전송됨
                                    // 슬레이브의 갑작스런 부하 증가
                                }
                            }
                            ```

        + AOF 리라이트 : 시간이 지나면서 AOF 파일은 계속해서 커지므로 주기적으로 파일을 압축하는 과정
        + 장점
            - 데이터 손실 최소화(최대 1초)
            - 사람이 읽을 수 있는 텍스트로 저장
            - 부분적 복구나 수정이 가능
            - 안전한 백업(append-only 특성)
                + 기존 데이터를 변경하지 않고 파일의 끝에 추가하는 방식
        + 단점
            - RDB보다 파일 크기가 큼
            - 복구 속도가 상대적으로 느림
            - RDB와 비교하여 동일한 데이터에 비해 더 많은 디스크 I/O 발생

### RDB 방식의 데이터 백업
+ RDB (Redis Database)
    - 일정 시점에 메모리에 저장된 데이터 전체를 저장(스냅샷 방식, 바이너리 파일로 저장)
    - 전통적인 데이터베이스 풀 백업과 유사
    - save 커맨드로 원하는 조건에 RDB 파일을 저장하도록 설정 가능
        ```bash
        save <기간(초)> <기간 내 변경된 키의 개수>
        dbfilename <RDB 파일 이름>
        dir <RDB 파일이 저장될 경로>

        save 900 1
        # 900초동안 1개 이상의 키가 변경된 경우, RDB 파일 생성
        ```
    - 수동으로 RDB 파일 생성
        + save
            - 동기식 백업 : 레디스가 백업이 완료될 때까지 클라이언트의 모든 요청을 차단
            - 내부동작 원리
                + 현재 처리 중인 명령 완료 대기
                + 클라이언트의 요청 완전 차단
                + 메인 스레드가 직접 메모리 데이터를 디스크에 직렬화
                + RDB 파일 생성 완료
                + 클라이언트 요청 처리 재개
        + bgsave
            - 비동기식 백업 : 백그라운드에서 백업을 진행하면서 클라이언트 요청을 계속하여 처리 
            - 내부동작 원리
                + fork() 실행 : 자식 프로세스 생성
                + 자식 프로세스가 메모리 데이터를 RDB 파일로 직렬화
                + 직렬화가 끝나면 자식 프로세스 종료
                + 백그라운드로 데이터가 저장되고 있을때, bgsave 커맨드를 실행하면 에러 발생
                    - 중복 실행을 막는 이유는 시스템 리소스 보호를 위해
                        + 메모리 사용량이 급증 : fork()로 자식 프로세스가 여러개 생성되므로 가용 메모리 부족
                        + 디스크 I/O 경합 : 두개의 bgsave 프로세스가 디스크에 쓰기 작업을 진행하면 각각 백업 속도 저하, 시스템 전체 성능 저하
                        + 파일 충돌 위험 : 하나의 rdb 파일에 쓰기 시도, 파일 손상 가능성, 원자성 위반
                    - bgsave schedule 옵션
                        + 우선 OK를 반환한 뒤, 백업이 완료되었을 때 다시 bgsave를 실행한다

    - 장점
        + 빠른 복구 속도로 대용량 데이터에 적합
        + 파일 크기가 상대적으로 작음(바이너리 형태로 저장)
        + 백업 파일의 무결성 검증 가능
        + 네트워크를 통한 원격 백업 용이
    - 단점
        + 마지막 백업 시점 이후의 데이터 손실 가능성
        + 대용량 데이터셋에서 fork() 작업시 메모리 사용량 증가
        + 백업 주기와 성능 사이의 트레이드오프 존재