## 레디스 데이터 백업 방법

### 레디스에서 데이터를 영구 저장하기
+ 레디스는 인메모리 데이터베이스
    - 따라서 예기치 못한 이유로 레디스 인스턴스가 재시작되면 메모리에 저장된 데이터의 유실가능성 존재
+ 복제와 백업의 차이
    - 복제
        + 레디스를 복제구조로 사용하는 경우, 데이터가 실시간으로 전달되니 백업의 필요성을 느끼지 못할 수도 있다
        + 하지만 데이터가 실시간으로 전달되므로 개발자의 실수, 프로그램 상의 버그로 데이터를 삭제하는 커맨드가 실행되면 되돌릴 수 없다
        + 복제는 가용성을 위한 것
    - 백업
        + 장애 상황에서 데이터의 복구를 위해 필요

### RDB 방식의 데이터 백업
+ RDB (Redis Database)
    - 일정 시점에 메모리에 저장된 데이터 전체를 저장(스냅샷 방식, 바이너리 파일로 저장)
    - 전통적인 데이터베이스 풀 백업과 유사
    - save 커맨드로 원하는 조건에 RDB 파일을 저장하도록 설정 가능
        ```bash
        save <기간(초)> <기간 내 변경된 키의 개수>
        dbfilename <RDB 파일 이름>
        dir <RDB 파일이 저장될 경로>

        save 900 1
        # 900초동안 1개 이상의 키가 변경된 경우, RDB 파일 생성
        ```
    - 수동으로 RDB 파일 생성
        + save
            - 동기식 백업 : 레디스가 백업이 완료될 때까지 클라이언트의 모든 요청을 차단
            - 내부동작 원리
                + 현재 처리 중인 명령 완료 대기
                + 클라이언트의 요청 완전 차단
                + 메인 스레드가 직접 메모리 데이터를 디스크에 직렬화
                + RDB 파일 생성 완료
                + 클라이언트 요청 처리 재개
        + bgsave
            - 비동기식 백업 : 백그라운드에서 백업을 진행하면서 클라이언트 요청을 계속하여 처리 
            - 내부동작 원리
                + fork() 실행 : 자식 프로세스 생성
                + 자식 프로세스가 메모리 데이터를 RDB 파일로 직렬화
                + 직렬화가 끝나면 자식 프로세스 종료
                + 백그라운드로 데이터가 저장되고 있을때, bgsave 커맨드를 실행하면 에러 발생
                    - 중복 실행을 막는 이유는 시스템 리소스 보호를 위해
                        + 메모리 사용량이 급증 : fork()로 자식 프로세스가 여러개 생성되므로 가용 메모리 부족
                        + 디스크 I/O 경합 : 두개의 bgsave 프로세스가 디스크에 쓰기 작업을 진행하면 각각 백업 속도 저하, 시스템 전체 성능 저하
                        + 파일 충돌 위험 : 하나의 rdb 파일에 쓰기 시도, 파일 손상 가능성, 원자성 위반
                    - bgsave schedule 옵션
                        + 우선 OK를 반환한 뒤, 백업이 완료되었을 때 다시 bgsave를 실행한다
        + lastsave로 RDB 파일이 정상적으로 저장됐는지 확인이 가능하다
    - 복제를 사용할 경우 자동으로 RDB 파일 생성
        + 복제본에서 replicaof 커맨드를 사용해 복제를 요청하면 마스터 노드에서 RDB 파일을 새로 생성해 전달한다
        + 이미 복제 연결이 된 상황에서 네트워크 등의 이슈로 인해 연결이 끊어진 경우, 재연결이 가능하며 마스터 노드에서 복제본으로 RDB 파일 전송을 재시작한다
    - 장점
        + 빠른 복구 속도로 대용량 데이터에 적합
        + 파일 크기가 상대적으로 작음(바이너리 형태로 저장)
        + 백업 파일의 무결성 검증 가능
        + 네트워크를 통한 원격 백업 용이
    - 단점
        + 마지막 백업 시점 이후의 데이터 손실 가능성
        + 대용량 데이터셋에서 fork() 작업시 메모리 사용량 증가
        + 백업 주기와 성능 사이의 트레이드오프 존재

### AOF 방식의 데이터 백업
+ AOF (Append Only File)
    - 레디스 인스턴스에서 수행된 모든 쓰기 작업의 로그를 차례대로 저장
        + 클라이언트로부터 받은 SET, DEL, INCR과 같은 커맨드를 텍스트 형태로 파일에 기록(레디스 프로토콜 형태 : RESP)
            ```bash
            # redis.conf 파일에서 AOF 설정
            appendonly yes   # AOF 활성화
            appendfilename "appendonly.aof" # AOF 파일명
            appendfsync everysec    # 동기화 정책
            ```
            - 레디스 기본 백업설정은 RDB
            - 왜 RDB가 기본 백업설정인가?
                + 성능우선
                    - RDB는 주기적 백업으로 성능 영향 최소
                    - AOF는 모든 쓰기 커맨드마다 디스크 I/O 발생
                + 메모리 효율성
                    - RDB는 압축된 바이너리 형태로 저장
                    - AOF는 텍스트 형태로 저장하여 더 많은 공간 차지
                + 복구 속도
                    - RDB는 바이너리 로딩으로 빠른 복구 가능
                    - AOF는 명령어 재실행으로 상대적으로 느린 복구
        + 복구시에는 데이터 변경 커맨드를 순서대로 재실행하여 데이터 복원
            - 항상 사용자가 실행한 커맨드를 그대로 저장하지 않음
                + 예를 들어, list 자료구조에서 블로킹 기능을 지원하는 brpop 커맨드의 경우, AOF는 rpop으로 기록
                    - AOF 파일에서 블로킹 기능을 명시할 필요가 없기때문
                + expire의 경우, pexpireat으로 변환
                    - expire는 상대시간이므로 pexpireat(절대시간)로 변환하여 저장
                    - 복구시 언제 실행되어도 동일한 만료 시간을 보장해야 하기 때문
                + increment/decrement 최적화
                    ```bash
                    # 사용자가 연속으로 실행
                    redis-cli> INCR counter
                    redis-cli> INCR counter  
                    redis-cli> INCR counter

                    counter
                    $1
                    3
                    # 3번의 INCR 대신 최종 값으로 SET
                    ```
    - 데이터베이스 트랜잭션 로그와 유사
    - 동기화 정책
        + always : 모든 명령마다 즉시 디스크에 동기화(최고 안전성, 성능 저하)
        + everysec : 1초마다 동기화(레디스 기본 정책)
        + no : 운영체제가 결정하는 시점에 동기화(성능 우선, 안전성 낮음)
        + 동기화 정책 중 고려사항
            - 디스크 I/O 성능
            - 네트워크 지연 시간
                + 클라이언트와 레디스 서버 간의 네트워크 지연이 큰 경우, AOF 동기화 정책보다 네트워크 성능이 더 큰 병목이 될 수 있다
            - 복제 환경
                + 마스터 슬레이브 구조에서는 마스터의 AOF 정책이 전체 시스템의 데이터 일관성에 영향을 미친다
                + 복제과정
                    - 클라이언트가 마스터에 쓰기 명령 전송
                    - 마스터가 자신의 메모리에 데이터 변경 적용
                    - 마스터가 클라이언트에 결과 응답
                    - 마스터가 슬레이브에게 복제 명령 전송(비동기)
                    - 슬레이브들이 각자의 타이밍에 데이터 적용
                + AOF 정책이 복제에 미치는 영향
                    - 마스터 장애시 데이터 불일치
                        + 마스터 : AOF everysec, 슬레이브 : AOF everysec
                    
                        ```bash
                        // 시간 순서대로 발생하는 상황
                        public class ReplicationConsistencyIssue {
                            public void demonstrateInconsistency() {
                                // T1: 클라이언트가 마스터에 데이터 쓰기
                                master.set("user:1001", "john_updated");
                                // 마스터는 메모리에만 저장, AOF는 OS에 맡김 (no 정책)
                                
                                // T2: 마스터가 클라이언트에 OK 응답
                                // 클라이언트는 데이터가 안전하게 저장되었다고 인식
                                
                                // T3: 마스터가 슬레이브에 복제 명령 전송 시작
                                // 하지만 아직 슬레이브에 도달하지 않음
                                
                                // T4: 갑작스런 마스터 서버 크래시 발생
                                // 마스터의 메모리 데이터 모두 손실
                                // AOF 파일에는 아직 기록되지 않음 (OS 캐시에만 존재)
                                
                                // T5: 슬레이브를 새로운 마스터로 승격
                                // 하지만 슬레이브는 "user:1001" 업데이트를 받지 못했음
                                // 결과: 클라이언트는 저장되었다고 생각하지만 실제로는 데이터 손실
                            }
                        }
                        ```

                    - 네트워크 연결 끊김
                        + 마스터와 슬레이브 간 네트워크 연결 단절
                        + 마스터 : AOF always, 슬레이브 : 네트워크 단절로 인해 복제 중단

                        ```bash
                        public class NetworkPartitionScenario {
                            public void handlePartitionedWrite() {
                                // 네트워크 분할 상황에서도 마스터는 계속 쓰기 요청 처리
                                while (networkPartitioned) {
                                    // 마스터는 AOF에 모든 변경사항 기록
                                    master.set("session:active", "user_data");  // AOF에 안전하게 저장
                                    
                                    // 하지만 슬레이브는 이 변경사항을 받지 못함
                                    // 슬레이브에서 읽기 작업 시 오래된 데이터 반환
                                }
                                
                                // 네트워크 복구 후 대량의 복제 데이터가 한 번에 전송됨
                                // 슬레이브의 갑작스런 부하 증가
                            }
                        }
                        ```

    - AOF 리라이트
        + 시간이 지나면서 AOF 파일은 계속해서 커지므로 주기적으로 파일을 압축하는 과정
        + 재구성 과정(버전 7 이전)
            - fork() 시스템 콜로 자식 프로세스 생성
            - 생성된 자식 프로세스는 레디스 메모리의 데이터를 읽어와 신규로 생성한 임시 파일에 저장
            - 백그라운드에서 위의 과정이 진행되는 동안 레디스 메모리의 데이터가 변경된 부분은 기존의 AOF 파일과 인메모리 버퍼에 저장
            - AOF 재구성 작업이 끝나면 인메모리 버퍼에 저장된 내용을 임시 파일 마지막에 추가
            - 생성된 임시파일로 기존 AOF 파일에 덮어씌운다
        + 재구성 과정(버전 7 이후)
            - fork() 시스템 콜로 자식 프로세스 생성
            - 생성된 자식 프로세스는 레디스 메모리의 데이터를 읽어와 신규로 생성한 임시 파일에 저장
            - 백그라운드에서 위의 과정이 진행되는 동안 레디스 메모리의 데이터가 변경된 부분은 기존 AOF 파일에 저장
            - AOF 재구성 작업이 끝나면 임시 매니페스트 파일을 생성한 후, 변경된 버전으로 매니페스트 파일을 업데이트한다
            - 생성된 임시 매니페스트 파일로 기존 매니페스트 파일을 덮어씌운 후, 이전 버전의 AOF, RDB 파일을 삭제한다
    - aof-use-rdb-preamble
        + 압축되는 AOF 파일의 형태를 결정
        + no : 베이스 파일은 base.aof, yes : 베이스 파일은 base.rdb
    - auto-aof-rewrite-percentage
        + AOF 리라이트를 시작하기 위한 시점을 정하는 옵션
        + 마지막으로 재구성한 AOF 파일의 크기를 비교해 현재 AOF 파일이 지정된 퍼센트만큼 커졌을 때, AOF 리라이트를 실행
            ```bash
            auto-aof-rewrite-percentage 100
            auto-aof-rewrite-min-size 67108864  #64mb
            > info persistence
            aof_current_size:186830
            aof_base_size:145802
            ```
        + aob_base_size는 145802고 aof_current_size는 186830
        + auto-aof-rewrite-percentage가 100이므로 aof_base_size의 100%만큼 커진 291604가 되면 리라이트를 시도
        + 데이터가 아무 것도 없는 상태로 부팅되면 auto_aof_rewrite_min_size를 기준으로 리라이트를 실행한다
    - bgrewriteaof
        + 수동으로 원하는 시점에 AOF 리라이트를 진행할 수 있다
    - aof-timestamp-enabled
        + 설정파일에서 aof-timestamp-enabled 옵션을 활성화하면 AOF 데이터가 저장될 때, 타임스탬프도 함께 저장된다
        + 저장된 타임스탬프와 redis-checkout-aof 프로그램을 사용하면 원하는 시점으로 데이터를 복구할 수 있다
        + 타임스탬프 기능은 레디스 7 버전 이후부터 지원되며 이 옵션을 켜서 저장한 AOF 파일은 이전 버전과 호환되지 않는다
    - 장점
        + 데이터 손실 최소화(최대 1초)
        + 사람이 읽을 수 있는 텍스트로 저장
        + 부분적 복구나 수정이 가능
        + 안전한 백업(append-only 특성)
            - 기존 데이터를 변경하지 않고 파일의 끝에 추가하는 방식
    - 단점
        + RDB보다 파일 크기가 큼
        + 복구 속도가 상대적으로 느림
        + RDB와 비교하여 동일한 데이터에 비해 더 많은 디스크 I/O 발생

### 백업을 사용할 때 주의할 점
+ RDB와 AOF를 사용하는 경우, 인스턴스의 maxmemory 값은 실제 서버의 메모리보다 여유를 갖고 설정하는 것을 권장
    - bgsave 커맨드로 RDB 파일을 저장하거나 AOF 리라이트를 진행할 때, 레디스는 fork()로 자식 프로세스를 생성
    - 생성된 자식 프로세스는 레디스의 메모리를 그대로 파일에 저장하며 동시에 부모 프로세스는 클라이언트의 연결을 처리해야 한다
        + 물리적 메모리에 있는 실제 메모리 페이지가 그대로 복제되기 때문에 최악의 경우 기존 메모리 용량의 2배를 사용할 수 있다
        + 또한, maxmemory 값을 너무 크게 설정한 경우, 레디스의 copy-on-write 동작으로 인해 OS 메모리가 가득 차는 상황이 발생할 수 있다