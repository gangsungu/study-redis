## 복제

### 가용성
+ 가용성은 일정 시간동안 서비스를 정상적으로 사용할 수 있는 시간의 비율, 값이 클수록 가용성이 높다
+ 서비스를 안정적으로 운영하기 위해서는 가용성을 높일 수 있는 방안을 고려해야 한다
    - 가용성이 높은 시스템을 고가용성 시스템이라고 부른다
+ 레디스에서 고가용성을 확보하기 위해 다음의 두가지 기능이 필요
    - 복제
        + 마스터 노드의 데이터를 복제본 노드로 실시간 복사하는 기능
        + 마스터 노드의 서버에 장애가 생겨 데이터가 유실되도 복제 노드에서 데이터를 확인할 수 있다
    - 자동 페일오버
        + 마스터 노드에서 발생한 장애를 감지해 레디스로 들어오는 클라이언트 연결을 자동으로 복제 노드로 리다이렉트하는 기능
        + 수동으로 레디스 엔드포인트를 변경할 필요가 없어 빠른 장애 조치가 가능하다

### 레디스에서의 복제 구조
+ 대부분의 데이터 저장소 애플리케이션은 자체적으로 복제 기능을 제공
+ 운영 중인 서비스에서 복제본 노드를 추가하는 이유
    - 데이터 저장소가 있는 하드웨어는 언제든 고장날 가능성이 있으므로 마스터 데이터베이스가 다운되면 대신 사용할 복제본이 필요
    - 대규모 서비스에서 복제본은 트래픽을 감소시키는 역할을 수행가능
        + 실시간으로 마스터 노드에 접근하는 트래픽이 많을 떄, 일부 트래픽이 복제본을 바라보게 한다면 부하 분산을 통해 마스터 노드의 트래픽을 줄일 수 있다
    - 운영 중인 마스터 노드에서 매번 데이터 백업을 진행하는 것은 부담스러운 작업
        + 백업을 복제본에서 수행하면 백업 작업이 서비스에 미치는 영향도를 최소화할 수 있다
+ MySQL이나 PostgreSQL은 멀티 마스터 복제 구조를 지원(모든 노드가 마스터이면서 복제본이 가능)
    - 하지만 레디스는 멀티 마스터 구조를 지원하지 않으며 마스터는 복제본이 될 수 없다
    - 레디스 2.6부터 복제본 노드는 기본으로 읽기 전용으로 실행되므로 읽기만 가능
    - 모든 데이터의 입력은 마스터에서 진행되는 것이 일반적이며 복제본은 마스터에서 변경된 데이터만 전달받는다

### 레디스 복제 구조 구성하기
+ 레디스 복제는 마스터-슬레이브 구조를 기반으로 함
    - 하나의 마스터가 여러개의 슬레이브를 가질 수 있으며 마스터의 변경사항이 슬레이브에게 자동으로 전파
    - 레디스 복제에서 슬레이브는 물리적으로 별도로 구성된 레디스 인스턴스
        ```bash
        # 마스터 Redis 인스턴스 시작
        redis-server --port 6379

        # 슬레이브1 Redis 인스턴스 시작 (같은 서버)
        redis-server --port 6380 --replicaof 127.0.0.1 6379

        # 슬레이브2 Redis 인스턴스 시작 (다른 서버)
        redis-server --port 6379 --replicaof 192.168.1.100 6379

        서버1 (192.168.1.100)
        ├── Redis Master (포트 6379)
        ├── Redis Slave1 (포트 6380)
        └── Redis Slave2 (포트 6381)
        ```

        + 레디스 클러스터와의 차이점
            - 레디스 복제(마스터-슬레이브)
                + 데이터 복제 : 모든 슬레이브가 마스터의 전체 데이터 보유
                + 목적 : 고가용성, 읽기 성능 향상
                + 데이터 분산 : 없음(모든 노드가 동일한 데이터)
            - 레디스 클러스터
                + 데이터 샤딩 : 데이터를 여러 노드에 분산 저장
                + 목적 : 수평적 확장, 대용량 데이터 처리
                + 데이터 분산 : 해시 슬롯 기반으로 데이터 분할
+ 복제본이 될 노드 B에서 replicaof 커맨드를 입력하여 복제를 시작할 수 있다
    ```bash
    replicaof <master-ip> <master-port>
    ```
    - 복제본 노드에서 또 다시 복제본 노드를 추가하는 것도 가능
+ 데이터를 복제할 때, masterauth 옵션에 패스워드를 입력해야 한다
    - 입력하는 패스워드는 마스터 노드의 패스워드를 입력해야 하며 패스워드를 입력하지 않으면 마스터에서 데이터를 받을 수 없다

### 복제 매커니즘
+ 레디스에서 데이터 복제의 모든 과정은 자동으로 이루어지며 개발자의 개입은 필요하지 않다
+ repl-diskless-sync
    - 레디스 복제 과정에서 디스크를 사용하지 않고 직접 네트워크를 통해 데이터를 전송하는 방식
    - 기존 복제방식과 차이점
        + 기존 방식(disk-based-sync)
            - 마스터가 메모리 데이터를 디스크에 RDB 파일로 저장
            - RDB 파일 생성 완료 후, 파일을 읽어서 슬레이브로 전송
            - 슬레이브가 RDB 파일을 디스크에 저장 후, 메모리에 로드
            ```bash
            마스터: 메모리 → 디스크(RDB) → 네트워크 → 슬레이브 디스크 → 슬레이브 메모리
            ```
        + Diskless 방식
            - 마스터가 메모리 데이터를 직접 네트워크로 스트리밍
            - 슬레이브가 직접 메모리로 로드하거나 임시 디스크 사용
            ```bash
            마스터: 메모리 → 네트워크 → 슬레이브 메모리
            ```
    - 버전 7 이전에서는 해당 옵션의 기본값은 no
        - 복제 과정
            + replicaof로 복제 연결 시도
            + 마스터 노드에서 fork로 자식 프로세스를 생성 후 RDB 스냅샷을 생성
            + 2번 과정동안 마스터 노드에서 수행된 모든 데이터셋 변경 작업은 레디스 프로토콜의 형태로 마스터 노드의 복제 버퍼에 저장된다
            + RDB 파일이 생성 완료되면 파일은 복제본 노드로 복사된다
            + 복제본에 저장된 모든 내용을 삭제한 뒤, RDB 파일을 이용하여 데이터를 로딩
            + 복제 과정동안 버퍼링됐던 복제 버퍼의 모든 데이터를 복제본으로 전달한다
        - 복제속도는 디스크 I/O의 영향을 받는다
            + 로컬디스크에 RDB 파일을 쓰는게 아닌 NAS와 같은 원격 디스크를 사용하면 디스크 I/O 속도는 더 느려질 수 있다
    - 버전 7 이후부터는 해당 옵션의 기본값은 yes
        - 복제 과정
            + replicaof로 복제 연결 시도
            + 마스터 노드는 소켓 통신을 이용해 복제본 노드에 바로 연결하며 RDB 파일은 생성됨과 동시에 점진적으로 복제본의 소켓에 전송된다
            + 2번 과정동안 마스터 노드에서 수행된 모든 데이터셋 변경 작업은 레디스 프로토콜의 형태로 마스터 노드의 복제 버퍼에 저장된다
            + 소켓에서 읽어온 RDB 파일을 복제본의 디스크에 저장한다
            + 복제본에 저장된 모든 데이터를 삭제한 뒤 RDB 파일 내용을 메모리에 로딩한다
            + 복제 버퍼의 데이터를 복제본으로 전달한다
        - 이 과정에서 repl-diskless-load 옵션은 기본으로 disabled
            + 소켓에서 읽어온 RDB 스냅샷 데이터를 바로 메모리에 로드하지 않고 복제본 노드의 디스크에 먼저 저장
            + 복제본 노드는 마스터에서 가져온 데이터를 불러오기 전에 자신의 데이터를 모두 삭제하는데, 이때 소켓 통신으로 받아온 RDB 데이터가 정상적인지 확인할 수 없기 때문에 데이터를 저장하는 과정을 선행한다
    - 장점
        + 디스크 I/O 절약
            - RDB 파일을 디스크에 쓰고 읽는 과정 생략
            - SSD 수명 연장(쓰기 작업 감소)
            - 디스크 공간 절약
        + 복제 속도 향상
            - 디스크 I/O 단계 제거로 지연 시간 감소
            - 네트워크 대역폭이 충분한 환경에서 유리
        + 동시 복제 효율성
    - 사용시 고려사항
        + 네트워크 의존성
            - 네트워크 대역폭이 충분해야 함
        + 메모리 압박 상황
            - 복제 중 마스터의 메모리 사용량 증가
                + 클라이언트 요청 처리와 동시에 복제 데이터 스트리밍을 진행하여 2중으로 부담
        + 에러 처리
            - 네트워크 오류시 전체 복제 재시작 필요
            - 디스크 기반 방식보다 복구 옵션이 제한적
        + 슬레이브 체인
+ repl-diskless-sync-delay 5
    - 새로운 복제 연결이 들어오면 설정한 시간을 기다린 뒤 복제 연결을 시작하는 옵션(기본값 5초)
    - 0으로 설정하면 멀티캐스팅이 비활성화
+ 레디스의 복제는 비동기식으로 동작한다
    - 마스터는 쓰기 명령을 실행하는 즉시 클라이언트에 응답
    - 슬레이브로의 전파는 별도로 수행
    - 짦은 지연시간과 높은 성능을 갖게 되지만 일시적으로 데이터 불일치 가능
        + 마스터가 쓰기 명령을 실행 후 클라이언트에게 응답했지만 슬레이브로 전파는 못한 과정에서 비정상 종료가 된 경우, 데이터 불일치가 발생
+ 복제ID
    - 마스터-슬레이브 간의 일관성을 보장하는 기능
    - 기본구조
        + 40자리 16진수 문자열로 구성되며 각 복제 세션의 고유한 식별자 역할
        ```bsah
        # 복제 ID 확인
        INFO replication

        # 출력 예시:
        # master_replid:40414fa3c7c1d8eaddd319a0e3d9b7f8b0e3c2a1
        # master_replid2:0000000000000000000000000000000000000000
        # master_repl_offset:12345
        ```
    - 생성과 관리
        + 마스터 시작시 자동 생성
            - SHA-1 해시 기반의 랜덤 ID
        + 새로운 복제 ID 생성 조건
            - 레디스 서버 재시작(Docker에 설치한 경우도 해당)
            - replicaof 명령어(슬레이브 -> 마스터 승격)
                + 승격시 복제 ID가 바뀌는 것은 복제 스트림의 독립성을 보장하기 위해
                + 슬레이브가 승격하면 이전 마스터의 복제 ID를 세컨더리 ID로 저장
                + 왜 저장하느냐?
                    - 다른 슬레이브와 부분 재동기화를 진행하기 위해

                ```bash
                # 초기 상태
                마스터 (복제ID: AAAA...1111, offset: 50000)
                ├── 슬레이브A (offset: 49990)  ← 가장 최신
                ├── 슬레이브B (offset: 49980)  
                └── 슬레이브C (offset: 49970)

                # 마스터 장애 → 슬레이브A 승격
                새마스터(구슬레이브A) 
                ├── Primary ID: BBBB...2222 (새로 생성)
                ├── Secondary ID: AAAA...1111 (이전 마스터 ID 보존)
                └── second_offset: 49990 (승격 시점 offset)

                # 슬레이브B 재연결 시도
                PSYNC AAAA...1111 49980  ← 기존 마스터 ID로 요청

                # 새마스터의 판단:
                # 1. Primary ID (BBBB...2222) != AAAA...1111 ✗
                # 2. Secondary ID (AAAA...1111) == AAAA...1111 ✓  
                # 3. offset 49980 <= second_offset 49990 ✓

                # 결론: 부분 동기화 허용!
                +CONTINUE BBBB...2222
                ```
            - 복제 연결이 초기화될 때
+ 백로그
    - 마스터가 슬레이브에게 전송한 복제 명령어를 저장하는 메모리 버퍼
    - 목적
        + 부분 재동기화
            ```bash
            # 상황: 슬레이브가 일시적으로 연결 끊어짐
            # 마스터 offset: 100000
            # 슬레이브 마지막 offset: 95000

            # 슬레이브 재연결 시:
            PSYNC <복제ID> 95000

            # 마스터 확인:
            # - offset 95000이 백로그 범위 내에 있는가?
            # - 백로그 first_offset: 90000, 현재: 100000
            # - 95000은 범위 내 → 부분 동기화 가능 ✓

            # offset 95000부터 100000까지의 명령어들을 백로그에서 추출
            # 예시:
            # 95001: SET key1 value1
            # 95020: DEL key2  
            # 95035: LPUSH list1 item1
            # ...
            # 99980: SET keyN valueN

            # 이 명령어들을 슬레이브에 순차 전송
            ```
    - 동작과정
        ```bash
        # 1. 클라이언트가 마스터에 쓰기 명령 실행
        SET user:1001 "John Doe"

        # 2. 마스터가 명령 처리
        # 3. 명령어를 백로그에 저장 (offset: 50001)
        # 4. 연결된 모든 슬레이브에 명령 전파
        # 5. 각 슬레이브의 offset 업데이트 추적
        ```